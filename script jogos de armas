-- ESP Script com Aim Assist ULTRA FORTE - ATIVA AO ATIRAR (CORRIGIDO)
-- Criado para Roblox
-- ðŸŽ¯ NOVO: Prioriza oponente mais prÃ³ximo por distÃ¢ncia 3D, nÃ£o por FOV
-- ðŸ‘» NOVO: Modo InvisÃ­vel - Fica transparente para outros jogadores

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

-- VariÃ¡veis globais
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

-- ConfiguraÃ§Ãµes
local ESP = {
    Enabled = false,
    TeamCheck = false,
    MaxDistance = 3000,
    BoxColor = Color3.fromRGB(255, 0, 0),
    TextColor = Color3.fromRGB(255, 255, 255),
    TextSize = 14
}

-- ConfiguraÃ§Ãµes do Aim Assist
local AimAssist = {
    Enabled = false,
    AlwaysOn = false,
    ShootToActivate = true,
    TeamCheck = true,
    Smoothness = 0.95,
    SnapSmoothness = 0.99,
    FOV = 1000,
    MaxDistance = 2000,
    TargetPart = "Head",
    WallCheck = false,
    MagnetMode = false,
    LockTarget = false,
    -- ðŸŽ¯ NOVO: Sistema de prioridade
    PriorityMode = "Distance", -- "Distance" (mais prÃ³ximo) ou "FOV" (mais central)
    MaxFOVForDistance = 800    -- Se usar modo Distance, sÃ³ considera jogadores dentro deste FOV
}

-- ðŸ‘» NOVO: ConfiguraÃ§Ãµes de Invisibilidade
local Invisibility = {
    Enabled = false,
    OriginalTransparency = {},
    InvisibleTransparency = 0.7, -- QuÃ£o transparente (0 = visÃ­vel, 1 = invisÃ­vel)
    HideName = true,             -- Esconde o nome acima da cabeÃ§a
    HideInESP = true             -- NÃ£o mostra seu ESP para outros (se servidor tiver anti-cheat que mostra ESP)
}

-- VariÃ¡veis de controle
local ESPObjects = {}
local CurrentTarget = nil
local LockedTarget = nil
local FOV_Circle = nil
local Connection = nil
local IsShooting = false
local LastClickTime = 0
local IsPanelVisible = true
local IsDraggingSlider = false
local InvisibilityConnection = nil
local OriginalCharacterProperties = {}

-- Atualizar referÃªncias
local function UpdateReferences()
    LocalPlayer = Players.LocalPlayer
    if LocalPlayer then
        Mouse = LocalPlayer:GetMouse()
    end
    Camera = Workspace.CurrentCamera
end

-- ðŸ‘» FUNÃ‡ÃƒO: Salvar transparÃªncia original das partes do personagem
local function SaveOriginalTransparency(character)
    OriginalCharacterProperties[character] = {}
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            OriginalCharacterProperties[character][part] = {
                Transparency = part.Transparency,
                CastShadow = part.CastShadow,
                LocalTransparencyModifier = part.LocalTransparencyModifier
            }
        elseif part:IsA("Decal") or part:IsA("Texture") then
            OriginalCharacterProperties[character][part] = {
                Transparency = part.Transparency
            }
        elseif part:IsA("BillboardGui") and Invisibility.HideName then
            OriginalCharacterProperties[character][part] = {
                Enabled = part.Enabled
            }
        end
    end
end

-- ðŸ‘» FUNÃ‡ÃƒO: Aplicar invisibilidade
local function ApplyInvisibility()
    if not LocalPlayer.Character then return end
    
    local character = LocalPlayer.Character
    
    -- Salva propriedades originais se ainda nÃ£o salvou
    if not OriginalCharacterProperties[character] then
        SaveOriginalTransparency(character)
    end
    
    -- Aplica transparÃªncia em todas as partes
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            -- MantÃ©m a hitbox (HumanoidRootPart) com transparÃªncia 0.5 para vocÃª nÃ£o ficar totalmente cego
            if part.Name == "HumanoidRootPart" then
                part.Transparency = 0.5
            else
                part.Transparency = Invisibility.InvisibleTransparency
            end
            part.CastShadow = false
            -- Para vocÃª mesmo ver seu personagem semi-transparente
            part.LocalTransparencyModifier = 0.3
        elseif part:IsA("Decal") or part:IsA("Texture") then
            part.Transparency = Invisibility.InvisibleTransparency
        elseif part:IsA("BillboardGui") and Invisibility.HideName then
            -- Esconde o nome/tag acima da cabeÃ§a
            part.Enabled = false
        end
    end
    
    -- Esconde acessÃ³rios (hats, etc)
    for _, accessory in pairs(character:GetChildren()) do
        if accessory:IsA("Accessory") then
            local handle = accessory:FindFirstChild("Handle")
            if handle and handle:IsA("BasePart") then
                handle.Transparency = Invisibility.InvisibleTransparency
                handle.CastShadow = false
                -- Esconde decals do acessÃ³rio
                for _, decal in pairs(handle:GetDescendants()) do
                    if decal:IsA("Decal") or decal:IsA("Texture") then
                        decal.Transparency = Invisibility.InvisibleTransparency
                    end
                end
            end
        end
    end
end

-- ðŸ‘» FUNÃ‡ÃƒO: Remover invisibilidade (voltar ao normal)
local function RemoveInvisibility()
    if not LocalPlayer.Character then return end
    
    local character = LocalPlayer.Character
    
    if OriginalCharacterProperties[character] then
        for obj, properties in pairs(OriginalCharacterProperties[character]) do
            if obj and obj.Parent then
                for prop, value in pairs(properties) do
                    pcall(function()
                        obj[prop] = value
                    end)
                end
            end
        end
    else
        -- Se nÃ£o tem dados salvos, apenas tenta deixar visÃ­vel
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Transparency = 0
                part.CastShadow = true
                part.LocalTransparencyModifier = 0
            elseif part:IsA("Decal") or part:IsA("Texture") then
                part.Transparency = 0
            elseif part:IsA("BillboardGui") then
                part.Enabled = true
            end
        end
    end
end

-- ðŸ‘» FUNÃ‡ÃƒO: Toggle invisibilidade
local function ToggleInvisibility()
    Invisibility.Enabled = not Invisibility.Enabled
    
    if Invisibility.Enabled then
        ApplyInvisibility()
        -- Conecta para manter invisÃ­vel quando respawnar ou mudar de roupa
        if InvisibilityConnection then InvisibilityConnection:Disconnect() end
        InvisibilityConnection = RunService.RenderStepped:Connect(function()
            if Invisibility.Enabled and LocalPlayer.Character then
                -- Verifica se alguma parte ficou visÃ­vel novamente (ex: trocou de roupa)
                for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                        if part.Transparency < Invisibility.InvisibleTransparency and part.Transparency ~= 1 then
                            part.Transparency = Invisibility.InvisibleTransparency
                            part.CastShadow = false
                        end
                    end
                end
            end
        end)
    else
        RemoveInvisibility()
        if InvisibilityConnection then
            InvisibilityConnection:Disconnect()
            InvisibilityConnection = nil
        end
    end
    
    return Invisibility.Enabled
end

-- Criar ESP
local function CreateESP(player)
    if player == LocalPlayer then return end
    if ESPObjects[player] then 
        for _, v in pairs(ESPObjects[player]) do
            if v then v:Remove() end
        end
    end
    
    local drawings = {}
    
    drawings.Box = Drawing.new("Square")
    drawings.Box.Visible = false
    drawings.Box.Color = ESP.BoxColor
    drawings.Box.Thickness = 2
    drawings.Box.Filled = false
    drawings.Box.Transparency = 1
    
    drawings.Name = Drawing.new("Text")
    drawings.Name.Visible = false
    drawings.Name.Color = ESP.TextColor
    drawings.Name.Size = ESP.TextSize
    drawings.Name.Center = true
    drawings.Name.Outline = true
    drawings.Name.OutlineColor = Color3.fromRGB(0, 0, 0)
    
    drawings.Distance = Drawing.new("Text")
    drawings.Distance.Visible = false
    drawings.Distance.Color = ESP.TextColor
    drawings.Distance.Size = ESP.TextSize - 2
    drawings.Distance.Center = true
    drawings.Distance.Outline = true
    drawings.Distance.OutlineColor = Color3.fromRGB(0, 0, 0)
    
    drawings.Line = Drawing.new("Line")
    drawings.Line.Visible = false
    drawings.Line.Color = Color3.fromRGB(255, 0, 0)
    drawings.Line.Thickness = 2
    
    ESPObjects[player] = drawings
end

local function RemoveESP(player)
    if ESPObjects[player] then
        for _, drawing in pairs(ESPObjects[player]) do
            if drawing then drawing:Remove() end
        end
        ESPObjects[player] = nil
    end
end

local function IsVisible(targetPosition)
    if not AimAssist.WallCheck then return true end
    if not LocalPlayer.Character then return false end
    
    local origin = Camera.CFrame.Position
    local direction = (targetPosition - origin).Unit * (targetPosition - origin).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local result = Workspace:Raycast(origin, direction, raycastParams)
    return result == nil
end

-- ðŸŽ¯ NOVA FUNÃ‡ÃƒO: Pega o jogador mais prÃ³ximo por DISTÃ‚NCIA 3D (nÃ£o por FOV)
local function GetClosestPlayerByDistance()
    if not LocalPlayer.Character then return nil end
    local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    local myRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myHumanoid or not myRoot or myHumanoid.Health <= 0 then return nil end
    
    local closestPlayer = nil
    local shortestDistance = AimAssist.MaxDistance -- Usa MaxDistance como limite
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    -- Se tem target travado e LockTarget estÃ¡ ativo, mantÃ©m ele
    if AimAssist.LockTarget and LockedTarget and LockedTarget.Character then
        local targetPart = LockedTarget.Character:FindFirstChild(AimAssist.TargetPart)
        local humanoid = LockedTarget.Character:FindFirstChild("Humanoid")
        if targetPart and humanoid and humanoid.Health > 0 then
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if onScreen then return LockedTarget end
        end
        LockedTarget = nil
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if AimAssist.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChild("Humanoid")
        local targetPart = character:FindFirstChild(AimAssist.TargetPart)
        
        if not humanoid or not targetPart or humanoid.Health <= 0 then continue end
        
        -- ðŸŽ¯ CALCULA DISTÃ‚NCIA 3D REAL (do seu personagem atÃ© o alvo)
        local distance3D = (myRoot.Position - targetPart.Position).Magnitude
        
        -- SÃ³ considera se estiver dentro da distÃ¢ncia mÃ¡xima
        if distance3D > AimAssist.MaxDistance then continue end
        
        -- Verifica se estÃ¡ na tela
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        -- ðŸŽ¯ VERIFICAÃ‡ÃƒO DE FOV: SÃ³ considera se estiver dentro do campo de visÃ£o configurado
        -- Isso evita que vire 180 graus para pegar alguÃ©m atrÃ¡s
        local screenDistance = (Vector2.new(screenPos.X, screenPos.Y) - centerScreen).Magnitude
        if screenDistance > AimAssist.MaxFOVForDistance then continue end
        
        -- Wall check
        if not IsVisible(targetPart.Position) then continue end
        
        -- ðŸŽ¯ PRIORIZA O MAIS PRÃ“XIMO (menor distÃ¢ncia 3D)
        if distance3D < shortestDistance then
            shortestDistance = distance3D
            closestPlayer = player
        end
    end
    
    if AimAssist.LockTarget and closestPlayer then
        LockedTarget = closestPlayer
    end
    
    return closestPlayer
end

-- ðŸŽ¯ FUNÃ‡ÃƒO ANTIGA (mantida para compatibilidade/modo alternativo): Pega o mais prÃ³ximo do centro da tela (FOV)
local function GetClosestPlayerByFOV()
    if not LocalPlayer.Character then return nil end
    local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    local myRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myHumanoid or not myRoot or myHumanoid.Health <= 0 then return nil end
    
    local closestPlayer = nil
    local shortestScreenDistance = AimAssist.FOV
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    if AimAssist.LockTarget and LockedTarget and LockedTarget.Character then
        local targetPart = LockedTarget.Character:FindFirstChild(AimAssist.TargetPart)
        local humanoid = LockedTarget.Character:FindFirstChild("Humanoid")
        if targetPart and humanoid and humanoid.Health > 0 then
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if onScreen then return LockedTarget end
        end
        LockedTarget = nil
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if AimAssist.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChild("Humanoid")
        local targetPart = character:FindFirstChild(AimAssist.TargetPart)
        
        if not humanoid or not targetPart or humanoid.Health <= 0 then continue end
        
        local distance3D = (myRoot.Position - targetPart.Position).Magnitude
        if distance3D > AimAssist.MaxDistance then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        if not IsVisible(targetPart.Position) then continue end
        
        local screenDistance = (Vector2.new(screenPos.X, screenPos.Y) - centerScreen).Magnitude
        if screenDistance < shortestScreenDistance then
            shortestScreenDistance = screenDistance
            closestPlayer = player
        end
    end
    
    if AimAssist.LockTarget and closestPlayer then
        LockedTarget = closestPlayer
    end
    
    return closestPlayer
end

-- ðŸŽ¯ FUNÃ‡ÃƒO UNIFICADA: Escolhe qual mÃ©todo usar baseado na configuraÃ§Ã£o
local function GetClosestPlayer()
    if AimAssist.PriorityMode == "Distance" then
        return GetClosestPlayerByDistance()
    else
        return GetClosestPlayerByFOV()
    end
end

local function ApplyAimAssist()
    UpdateReferences()
    
    local shouldApply = AimAssist.AlwaysOn or (AimAssist.Enabled and (not AimAssist.ShootToActivate or IsShooting))
    
    if not shouldApply then 
        CurrentTarget = nil
        return 
    end
    
    if not LocalPlayer.Character then return end
    local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if not myHumanoid or myHumanoid.Health <= 0 then return end
    
    CurrentTarget = GetClosestPlayer()
    
    if CurrentTarget and CurrentTarget.Character then
        local targetPart = CurrentTarget.Character:FindFirstChild(AimAssist.TargetPart)
        if targetPart then
            local targetPos = targetPart.Position
            if AimAssist.TargetPart == "Head" then
                targetPos = targetPos + Vector3.new(0, 0.2, 0)
            end
            
            local cameraCF = Camera.CFrame
            local targetCF = CFrame.new(cameraCF.Position, targetPos)
            
            local screenPos = Camera:WorldToViewportPoint(targetPos)
            local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            local distanceFromCenter = (Vector2.new(screenPos.X, screenPos.Y) - centerScreen).Magnitude
            
            local smoothValue
            if distanceFromCenter < 30 then
                smoothValue = AimAssist.SnapSmoothness
            elseif distanceFromCenter < 100 then
                smoothValue = 0.95
            elseif AimAssist.MagnetMode then
                smoothValue = 0.9
            else
                smoothValue = AimAssist.Smoothness
            end
            
            Camera.CFrame = cameraCF:Lerp(targetCF, smoothValue)
        end
    else
        LockedTarget = nil
    end
end

local function UpdateESP()
    UpdateReferences()
    
    if not LocalPlayer.Character then return end
    local myRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    if FOV_Circle then
        local showCircle = AimAssist.AlwaysOn or (AimAssist.Enabled and (IsShooting or not AimAssist.ShootToActivate))
        FOV_Circle.Visible = showCircle
        FOV_Circle.Position = centerScreen
        
        -- ðŸŽ¯ Mostra o raio apropriado baseado no modo
        if AimAssist.PriorityMode == "Distance" then
            FOV_Circle.Radius = AimAssist.MaxFOVForDistance
            FOV_Circle.Color = Color3.fromRGB(0, 255, 255) -- Ciano para modo distÃ¢ncia
        else
            FOV_Circle.Radius = AimAssist.FOV
            FOV_Circle.Color = Color3.fromRGB(255, 0, 0) -- Vermelho para modo FOV
        end
        
        if CurrentTarget and IsShooting then
            FOV_Circle.Thickness = 3
            FOV_Circle.Color = Color3.fromRGB(255, 0, 0)
        elseif CurrentTarget then
            FOV_Circle.Thickness = 2
            FOV_Circle.Color = Color3.fromRGB(255, 255, 0)
        else
            FOV_Circle.Thickness = 1
            FOV_Circle.Color = Color3.fromRGB(100, 100, 100)
        end
    end
    
    for player, drawings in pairs(ESPObjects) do
        if not ESP.Enabled then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        local character = player.Character
        if not character then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        
        if not humanoid or not rootPart or humanoid.Health <= 0 then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        if ESP.TeamCheck and player.Team == LocalPlayer.Team then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        local rootPosition, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
        local distance = (myRoot.Position - rootPart.Position).Magnitude
        
        if not onScreen or distance > ESP.MaxDistance then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        local size = math.clamp(2000 / rootPosition.Z, 10, 200)
        local width = size * 0.6
        local height = size * 1.2
        
        drawings.Box.Size = Vector2.new(width, height)
        drawings.Box.Position = Vector2.new(rootPosition.X - width/2, rootPosition.Y - height/2)
        drawings.Box.Visible = true
        
        if player == CurrentTarget then
            if IsShooting then
                drawings.Box.Color = Color3.fromRGB(255, 0, 0)
                drawings.Box.Thickness = 5
            else
                drawings.Box.Color = AimAssist.MagnetMode and Color3.fromRGB(255, 0, 255) or Color3.fromRGB(255, 255, 0)
                drawings.Box.Thickness = 3
            end
            drawings.Box.Filled = true
            drawings.Box.Transparency = 0.3
            
            drawings.Line.From = centerScreen
            drawings.Line.To = Vector2.new(rootPosition.X, rootPosition.Y)
            drawings.Line.Visible = true
            drawings.Line.Color = IsShooting and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 255, 0)
        else
            drawings.Box.Color = ESP.BoxColor
            drawings.Box.Thickness = 2
            drawings.Box.Filled = false
            drawings.Line.Visible = false
        end
        
        drawings.Name.Text = player.Name .. (player == CurrentTarget and (IsShooting and " [FIRING]" or " [TARGET]") or "")
        drawings.Name.Position = Vector2.new(rootPosition.X, rootPosition.Y - height/2 - 15)
        drawings.Name.Visible = true
        drawings.Name.Color = (player == CurrentTarget) and (IsShooting and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 255, 0)) or ESP.TextColor
        drawings.Name.Size = (player == CurrentTarget) and 16 or ESP.TextSize
        
        drawings.Distance.Text = math.floor(distance) .. "m"
        drawings.Distance.Position = Vector2.new(rootPosition.X, rootPosition.Y + height/2 + 5)
        drawings.Distance.Visible = true
    end
end

-- Interface
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "ESPMenu"
ScreenGui.Parent = game.CoreGui
ScreenGui.ResetOnSpawn = false

local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 260, 0, 620) -- Aumentado para caber novo botÃ£o
MainFrame.Position = UDim2.new(0, 20, 0, 20)
MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
MainFrame.BorderSizePixel = 0
MainFrame.Active = true
MainFrame.Draggable = true
MainFrame.Parent = ScreenGui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 8)
UICorner.Parent = MainFrame

-- TÃ­tulo
local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, 0, 0, 35)
Title.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
Title.BorderSizePixel = 0
Title.Text = "ðŸ”¥ AIM ASSIST ULTRA ðŸ”¥"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 18
Title.Font = Enum.Font.GothamBold
Title.Parent = MainFrame

local TitleCorner = Instance.new("UICorner")
TitleCorner.CornerRadius = UDim.new(0, 8)
TitleCorner.Parent = Title

-- FunÃ§Ã£o botÃ£o
local function CreateButton(name, posY, color, textSize)
    local Button = Instance.new("TextButton")
    Button.Size = UDim2.new(0.9, 0, 0, 28)
    Button.Position = UDim2.new(0.05, 0, 0, posY)
    Button.BackgroundColor3 = color or Color3.fromRGB(70, 70, 70)
    Button.BorderSizePixel = 0
    Button.Text = name .. ": OFF"
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.TextSize = textSize or 11
    Button.Font = Enum.Font.GothamBold
    Button.Parent = MainFrame
    
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 6)
    Corner.Parent = Button
    
    return Button
end

-- BotÃµes
local ToggleESP = CreateButton("ESP", 40, Color3.fromRGB(200, 50, 50))
local ToggleAim = CreateButton("AIM ASSIST", 72, Color3.fromRGB(200, 50, 50), 12)
local ToggleShootMode = CreateButton("ON SHOOT ONLY", 104, Color3.fromRGB(0, 100, 200))
local ToggleMagnet = CreateButton("MAGNET MODE", 136, Color3.fromRGB(150, 0, 150))
local ToggleLock = CreateButton("LOCK TARGET", 168, Color3.fromRGB(100, 100, 0))
local ToggleTeamESP = CreateButton("Team Check ESP", 200, Color3.fromRGB(70, 70, 70))
local ToggleTeamAim = CreateButton("Team Check Aim", 232, Color3.fromRGB(50, 150, 50))
local ToggleWallCheck = CreateButton("Wall Check", 264, Color3.fromRGB(70, 70, 70))
local TogglePriority = CreateButton("PRIORITY: DISTANCE", 296, Color3.fromRGB(0, 150, 255), 11)

-- ðŸ‘» NOVO BOTÃƒO: Invisibilidade
local ToggleInvis = CreateButton("INVISIBILITY", 328, Color3.fromRGB(100, 0, 150), 11)

-- BotÃ£o para esconder/mostrar painel
local TogglePanel = CreateButton("HIDE PANEL", 360, Color3.fromRGB(100, 100, 100))
TogglePanel.Text = "HIDE PANEL ðŸ‘ï¸"

-- Container do Slider de FOV
local SliderContainer = Instance.new("Frame")
SliderContainer.Size = UDim2.new(0.9, 0, 0, 50)
SliderContainer.Position = UDim2.new(0.05, 0, 0, 392)
SliderContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
SliderContainer.BorderSizePixel = 0
SliderContainer.Parent = MainFrame

local SliderCorner = Instance.new("UICorner")
SliderCorner.CornerRadius = UDim.new(0, 6)
SliderCorner.Parent = SliderContainer

-- Label do FOV
local FOVLabel = Instance.new("TextLabel")
FOVLabel.Size = UDim2.new(1, 0, 0, 20)
FOVLabel.Position = UDim2.new(0, 0, 0, 5)
FOVLabel.BackgroundTransparency = 1
FOVLabel.Text = "FOV: 1000"
FOVLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
FOVLabel.TextSize = 12
FOVLabel.Font = Enum.Font.GothamBold
FOVLabel.Parent = SliderContainer

-- Barra de fundo do slider
local SliderBG = Instance.new("Frame")
SliderBG.Size = UDim2.new(0.9, 0, 0, 8)
SliderBG.Position = UDim2.new(0.05, 0, 0, 28)
SliderBG.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
SliderBG.BorderSizePixel = 0
SliderBG.Parent = SliderContainer

local SliderBGCorner = Instance.new("UICorner")
SliderBGCorner.CornerRadius = UDim.new(0, 4)
SliderBGCorner.Parent = SliderBG

-- Barra de preenchimento
local SliderFill = Instance.new("Frame")
SliderFill.Size = UDim2.new(0.5, 0, 1, 0)
SliderFill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
SliderFill.BorderSizePixel = 0
SliderFill.Parent = SliderBG

local SliderFillCorner = Instance.new("UICorner")
SliderFillCorner.CornerRadius = UDim.new(0, 4)
SliderFillCorner.Parent = SliderFill

-- BotÃ£o arrastÃ¡vel
local SliderKnob = Instance.new("TextButton")
SliderKnob.Size = UDim2.new(0, 16, 0, 16)
SliderKnob.Position = UDim2.new(0.5, -8, 0.5, -8)
SliderKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
SliderKnob.BorderSizePixel = 0
SliderKnob.Text = ""
SliderKnob.Parent = SliderBG

local SliderKnobCorner = Instance.new("UICorner")
SliderKnobCorner.CornerRadius = UDim.new(1, 0)
SliderKnobCorner.Parent = SliderKnob

-- Labels min/max
local MinLabel = Instance.new("TextLabel")
MinLabel.Size = UDim2.new(0, 30, 0, 15)
MinLabel.Position = UDim2.new(0.05, 0, 0, 38)
MinLabel.BackgroundTransparency = 1
MinLabel.Text = "10"
MinLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
MinLabel.TextSize = 9
MinLabel.Font = Enum.Font.Gotham
MinLabel.Parent = SliderContainer

local MaxLabel = Instance.new("TextLabel")
MaxLabel.Size = UDim2.new(0, 30, 0, 15)
MaxLabel.Position = UDim2.new(0.85, 0, 0, 38)
MaxLabel.BackgroundTransparency = 1
MaxLabel.Text = "1500"
MaxLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
MaxLabel.TextSize = 9
MaxLabel.Font = Enum.Font.Gotham
MaxLabel.Parent = SliderContainer

-- Status label
local StatusLabel = Instance.new("TextLabel")
StatusLabel.Size = UDim2.new(0.9, 0, 0, 20)
StatusLabel.Position = UDim2.new(0.05, 0, 0, 446)
StatusLabel.BackgroundTransparency = 1
StatusLabel.Text = "Status: Esperando tiro..."
StatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
StatusLabel.TextSize = 10
StatusLabel.Font = Enum.Font.GothamBold
StatusLabel.Parent = MainFrame

-- Label modo
local ModeLabel = Instance.new("TextLabel")
ModeLabel.Size = UDim2.new(0.9, 0, 0, 30)
ModeLabel.Position = UDim2.new(0.05, 0, 0, 469)
ModeLabel.BackgroundTransparency = 1
ModeLabel.Text = "MODO: Clique esquerdo para ativar aim"
ModeLabel.TextColor3 = Color3.fromRGB(0, 200, 255)
ModeLabel.TextSize = 10
ModeLabel.Font = Enum.Font.Gotham
ModeLabel.TextWrapped = true
ModeLabel.Parent = MainFrame

-- ðŸŽ¯ Label de prioridade
local PriorityLabel = Instance.new("TextLabel")
PriorityLabel.Size = UDim2.new(0.9, 0, 0, 20)
PriorityLabel.Position = UDim2.new(0.05, 0, 0, 499)
PriorityLabel.BackgroundTransparency = 1
PriorityLabel.Text = "ðŸŽ¯ Alvo: Mais prÃ³ximo (3D)"
PriorityLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
PriorityLabel.TextSize = 10
PriorityLabel.Font = Enum.Font.GothamBold
PriorityLabel.Parent = MainFrame

-- ðŸ‘» NOVO LABEL: Status de invisibilidade
local InvisLabel = Instance.new("TextLabel")
InvisLabel.Size = UDim2.new(0.9, 0, 0, 20)
InvisLabel.Position = UDim2.new(0.05, 0, 0, 519)
InvisLabel.BackgroundTransparency = 1
InvisLabel.Text = "ðŸ‘» Visibilidade: Normal"
InvisLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
InvisLabel.TextSize = 10
InvisLabel.Font = Enum.Font.GothamBold
InvisLabel.Parent = MainFrame

-- Aviso
local WarningLabel = Instance.new("TextLabel")
WarningLabel.Size = UDim2.new(0.9, 0, 0, 25)
WarningLabel.Position = UDim2.new(0.05, 0, 0, 585)
WarningLabel.BackgroundTransparency = 1
WarningLabel.Text = "âš ï¸ ULTRA FORTE | Smooth: 0.95"
WarningLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
WarningLabel.TextSize = 10
WarningLabel.Font = Enum.Font.Gotham
WarningLabel.Parent = MainFrame

-- FunÃ§Ã£o para atualizar o slider
local function UpdateSlider(input)
    local relativeX = math.clamp((input.Position.X - SliderBG.AbsolutePosition.X) / SliderBG.AbsoluteSize.X, 0, 1)
    local newFOV = math.floor(10 + (relativeX * 1490))
    
    -- ðŸŽ¯ Atualiza o valor apropriado baseado no modo
    if AimAssist.PriorityMode == "Distance" then
        AimAssist.MaxFOVForDistance = newFOV
        FOVLabel.Text = "Max FOV Dist: " .. newFOV .. (newFOV >= 1400 and " (MAX)" or newFOV <= 20 and " (MIN)" or "")
    else
        AimAssist.FOV = newFOV
        FOVLabel.Text = "FOV: " .. newFOV .. (newFOV >= 1400 and " (MAX)" or newFOV <= 20 and " (MIN)" or "")
    end
    
    SliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
    SliderKnob.Position = UDim2.new(relativeX, -8, 0.5, -8)
    
    if FOV_Circle then 
        if AimAssist.PriorityMode == "Distance" then
            FOV_Circle.Radius = AimAssist.MaxFOVForDistance
        else
            FOV_Circle.Radius = newFOV 
        end
    end
end

-- Eventos do slider
SliderKnob.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        IsDraggingSlider = true
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if IsDraggingSlider and input.UserInputType == Enum.UserInputType.MouseMovement then
        UpdateSlider(input)
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        IsDraggingSlider = false
    end
end)

SliderBG.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        UpdateSlider(input)
    end
end)

-- FunÃ§Ãµes botÃµes
ToggleESP.MouseButton1Click:Connect(function()
    ESP.Enabled = not ESP.Enabled
    ToggleESP.Text = "ESP: " .. (ESP.Enabled and "ON" or "OFF")
    ToggleESP.BackgroundColor3 = ESP.Enabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(200, 50, 50)
end)

ToggleAim.MouseButton1Click:Connect(function()
    AimAssist.Enabled = not AimAssist.Enabled
    ToggleAim.Text = "AIM ASSIST: " .. (AimAssist.Enabled and "ON ðŸ”¥" or "OFF")
    ToggleAim.BackgroundColor3 = AimAssist.Enabled and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(200, 50, 50)
    if AimAssist.Enabled then
        Title.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        wait(0.2)
        Title.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
    end
end)

ToggleShootMode.MouseButton1Click:Connect(function()
    AimAssist.ShootToActivate = not AimAssist.ShootToActivate
    if AimAssist.ShootToActivate then
        ToggleShootMode.Text = "ON SHOOT ONLY: ON ðŸŽ¯"
        ToggleShootMode.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
        ModeLabel.Text = "MODO: Clique esquerdo para ativar aim"
        ModeLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
    else
        ToggleShootMode.Text = "ALWAYS ON: ON âš¡"
        ToggleShootMode.BackgroundColor3 = Color3.fromRGB(255, 100, 0)
        ModeLabel.Text = "MODO: Sempre ativo quando ligado"
        ModeLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
    end
end)

ToggleMagnet.MouseButton1Click:Connect(function()
    AimAssist.MagnetMode = not AimAssist.MagnetMode
    ToggleMagnet.Text = "MAGNET: " .. (AimAssist.MagnetMode and "ON ðŸ§²" or "OFF")
    ToggleMagnet.BackgroundColor3 = AimAssist.MagnetMode and Color3.fromRGB(255, 0, 255) or Color3.fromRGB(150, 0, 150)
end)

ToggleLock.MouseButton1Click:Connect(function()
    AimAssist.LockTarget = not AimAssist.LockTarget
    ToggleLock.Text = "LOCK: " .. (AimAssist.LockTarget and "ON ðŸ”’" or "OFF")
    ToggleLock.BackgroundColor3 = AimAssist.LockTarget and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(100, 100, 0)
end)

ToggleTeamESP.MouseButton1Click:Connect(function()
    ESP.TeamCheck = not ESP.TeamCheck
    ToggleTeamESP.Text = "Team ESP: " .. (ESP.TeamCheck and "ON" or "OFF")
    ToggleTeamESP.BackgroundColor3 = ESP.TeamCheck and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(70, 70, 70)
end)

ToggleTeamAim.MouseButton1Click:Connect(function()
    AimAssist.TeamCheck = not AimAssist.TeamCheck
    ToggleTeamAim.Text = "Team Aim: " .. (AimAssist.TeamCheck and "ON" or "OFF")
    ToggleTeamAim.BackgroundColor3 = AimAssist.TeamCheck and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(50, 150, 50)
end)

ToggleWallCheck.MouseButton1Click:Connect(function()
    AimAssist.WallCheck = not AimAssist.WallCheck
    ToggleWallCheck.Text = "Wall Check: " .. (AimAssist.WallCheck and "ON" or "OFF")
    ToggleWallCheck.BackgroundColor3 = AimAssist.WallCheck and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(70, 70, 70)
end)

TogglePriority.MouseButton1Click:Connect(function()
    if AimAssist.PriorityMode == "Distance" then
        AimAssist.PriorityMode = "FOV"
        TogglePriority.Text = "PRIORITY: FOV (CENTER)"
        TogglePriority.BackgroundColor3 = Color3.fromRGB(255, 100, 0)
        PriorityLabel.Text = "ðŸŽ¯ Alvo: Mais central (tela)"
        PriorityLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
        -- Atualiza o slider para mostrar FOV
        local relativeX = math.clamp((AimAssist.FOV - 10) / 1490, 0, 1)
        SliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
        SliderKnob.Position = UDim2.new(relativeX, -8, 0.5, -8)
        FOVLabel.Text = "FOV: " .. AimAssist.FOV
    else
        AimAssist.PriorityMode = "Distance"
        TogglePriority.Text = "PRIORITY: DISTANCE"
        TogglePriority.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
        PriorityLabel.Text = "ðŸŽ¯ Alvo: Mais prÃ³ximo (3D)"
        PriorityLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
        -- Atualiza o slider para mostrar MaxFOVForDistance
        local relativeX = math.clamp((AimAssist.MaxFOVForDistance - 10) / 1490, 0, 1)
        SliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
        SliderKnob.Position = UDim2.new(relativeX, -8, 0.5, -8)
        FOVLabel.Text = "Max FOV Dist: " .. AimAssist.MaxFOVForDistance
    end
end)

-- ðŸ‘» NOVO: FunÃ§Ã£o do botÃ£o de invisibilidade
ToggleInvis.MouseButton1Click:Connect(function()
    local isInvisible = ToggleInvisibility()
    if isInvisible then
        ToggleInvis.Text = "INVISIBILITY: ON ðŸ‘»"
        ToggleInvis.BackgroundColor3 = Color3.fromRGB(150, 0, 255)
        InvisLabel.Text = "ðŸ‘» Visibilidade: INVISÃVEL (70%)"
        InvisLabel.TextColor3 = Color3.fromRGB(200, 100, 255)
    else
        ToggleInvis.Text = "INVISIBILITY: OFF"
        ToggleInvis.BackgroundColor3 = Color3.fromRGB(100, 0, 150)
        InvisLabel.Text = "ðŸ‘» Visibilidade: Normal"
        InvisLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    end
end)

-- FunÃ§Ã£o do botÃ£o esconder/mostrar painel
TogglePanel.MouseButton1Click:Connect(function()
    IsPanelVisible = not IsPanelVisible
    local elementsToToggle = {ToggleESP, ToggleAim, ToggleShootMode, ToggleMagnet, ToggleLock, ToggleTeamESP, ToggleTeamAim, ToggleWallCheck, TogglePriority, ToggleInvis, StatusLabel, SliderContainer, ModeLabel, PriorityLabel, InvisLabel, WarningLabel}
    for _, element in ipairs(elementsToToggle) do
        if element and element:IsA("GuiObject") then
            element.Visible = IsPanelVisible
        end
    end
    if IsPanelVisible then
        MainFrame.Size = UDim2.new(0, 260, 0, 620)
        TogglePanel.Position = UDim2.new(0.05, 0, 0, 360)
        TogglePanel.Text = "HIDE PANEL ðŸ‘ï¸"
        TogglePanel.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
        Title.Text = "ðŸ”¥ AIM ASSIST ULTRA ðŸ”¥"
    else
        MainFrame.Size = UDim2.new(0, 260, 0, 70)
        TogglePanel.Position = UDim2.new(0.05, 0, 0, 40)
        TogglePanel.Text = "SHOW PANEL ðŸ‘ï¸â€ðŸ—¨ï¸"
        TogglePanel.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
        Title.Text = "ðŸ”¥ MENU ðŸ”¥"
    end
end)

-- FOV Circle
FOV_Circle = Drawing.new("Circle")
FOV_Circle.Visible = false
FOV_Circle.Thickness = 2
FOV_Circle.NumSides = 64
FOV_Circle.Radius = AimAssist.MaxFOVForDistance -- ComeÃ§a com o do modo Distance
FOV_Circle.Filled = false
FOV_Circle.Transparency = 0.3
FOV_Circle.Color = Color3.fromRGB(0, 255, 255) -- Ciano para indicar modo distÃ¢ncia

-- Loop principal
if Connection then Connection:Disconnect() end
Connection = RunService.RenderStepped:Connect(function()
    ApplyAimAssist()
    UpdateESP()
    if IsShooting then
        StatusLabel.Text = "Status: ATIRANDO - Aim Ativo!"
        StatusLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
    elseif AimAssist.Enabled and AimAssist.ShootToActivate then
        StatusLabel.Text = "Status: Esperando tiro..."
        StatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
    elseif AimAssist.Enabled then
        StatusLabel.Text = "Status: Sempre Ativo"
        StatusLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
    else
        StatusLabel.Text = "Status: Desativado"
        StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
    end
end)

-- Criar ESP para jogadores existentes
for _, player in pairs(Players:GetPlayers()) do
    CreateESP(player)
end

Players.PlayerAdded:Connect(function(player)
    wait(1)
    CreateESP(player)
end)

Players.PlayerRemoving:Connect(RemoveESP)

-- Sistema de detecÃ§Ã£o de tiro
Mouse.Button1Down:Connect(function()
    IsShooting = true
    LastClickTime = tick()
end)

Mouse.Button1Up:Connect(function()
    IsShooting = false
    LockedTarget = nil
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch or input.KeyCode == Enum.KeyCode.Space or input.KeyCode == Enum.KeyCode.Q then
        IsShooting = true
        LastClickTime = tick()
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch or input.KeyCode == Enum.KeyCode.Space or input.KeyCode == Enum.KeyCode.Q then
        IsShooting = false
        LockedTarget = nil
    end
end)

spawn(function()
    while wait(0.05) do
        if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
            if not IsShooting then IsShooting = true end
        else
            if IsShooting then IsShooting = false LockedTarget = nil end
        end
        if IsShooting and (tick() - LastClickTime) > 3 then
            IsShooting = false
            LockedTarget = nil
        end
    end
end)

-- TECLA F COMO TOGGLE (CLICA PARA LIGAR, CLICA PARA DESLIGAR)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Insert then
        TogglePanel.MouseButton1Click:Fire()
    end
    if input.KeyCode == Enum.KeyCode.F then
        -- Toggle do Aim Assist (liga/desliga com um clique)
        AimAssist.Enabled = not AimAssist.Enabled
        ToggleAim.Text = "AIM ASSIST: " .. (AimAssist.Enabled and "ON ðŸ”¥" or "OFF")
        ToggleAim.BackgroundColor3 = AimAssist.Enabled and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(200, 50, 50)
        if AimAssist.Enabled then
            Title.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            wait(0.2)
            Title.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
        end
    end
    -- ðŸ‘» NOVO: Tecla V para invisibilidade
    if input.KeyCode == Enum.KeyCode.V then
        ToggleInvis.MouseButton1Click:Fire()
    end
end)

-- ðŸ‘» NOVO: Reaplica invisibilidade quando respawnar
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    wait(2)
    UpdateReferences()
    
    -- Se estava invisÃ­vel, reaplica no novo personagem
    if Invisibility.Enabled then
        wait(0.5) -- Espera o personagem carregar completamente
        SaveOriginalTransparency(newCharacter)
        ApplyInvisibility()
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if not ESPObjects[player] then
            CreateESP(player)
        end
    end
end)

-- Inicializar
ToggleShootMode.Text = "ON SHOOT ONLY: ON ðŸŽ¯"
ToggleShootMode.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
TogglePriority.Text = "PRIORITY: DISTANCE ðŸŽ¯"
TogglePriority.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
ToggleInvis.Text = "INVISIBILITY: OFF ðŸ‘»"
ToggleInvis.BackgroundColor3 = Color3.fromRGB(100, 0, 150)

print("=== ðŸ”¥ AIM ASSIST ULTRA - ATIVA AO ATIRAR ðŸ”¥ ===")
print("ðŸŽ¯ NOVO: Sistema de prioridade por DISTÃ‚NCIA 3D")
print("ðŸ‘» NOVO: Modo InvisÃ­vel (Tecla V)")
print("FORÃ‡A: 95% (0.95 smoothness)")
print("F = Toggle Aim Assist (liga/desliga)")
print("V = Toggle Invisibilidade")
print("Insert = Esconder/mostrar painel")
print("Modo Distance: Pega o inimigo mais prÃ³ximo de vocÃª (nÃ£o mais central)")
