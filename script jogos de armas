-- ESP + Aim Assist ULTRA FORTE - VERS√ÉO FINAL MESCLADA
-- Combina: Interface da v2 + Funcionalidades avan√ßadas da v1
-- Criado para Roblox - 2025

-- Verifica se j√° est√° rodando
if getgenv().ESPUltraRunning then
    warn("Script j√° est√° rodando!")
    return
end
getgenv().ESPUltraRunning = true

-- Servi√ßos
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")

-- Vari√°veis globais
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

-- Aguarda o personagem carregar
if not LocalPlayer.Character then
    LocalPlayer.CharacterAdded:Wait()
end

-- Verifica Drawing library
local Drawing = Drawing or getgenv().Drawing
if not Drawing then
    warn("Drawing library n√£o dispon√≠vel!")
    return
end

-- Configura√ß√µes ESP
local ESP = {
    Enabled = false,
    TeamCheck = false,
    MaxDistance = 3000,
    BoxColor = Color3.fromRGB(255, 0, 0),
    TextColor = Color3.fromRGB(255, 255, 255),
    TextSize = 14,
    Boxes = true,
    Names = true,
    Distances = true,
    Tracers = true
}

-- Configura√ß√µes Aim Assist (Valores ULTRA FORTES da v2)
local AimAssist = {
    Enabled = false,
    AlwaysOn = false,
    ShootToActivate = true,
    TeamCheck = true,
    Smoothness = 0.95,        -- ULTRA FORTE (0.95 = quase instant√¢neo)
    SnapSmoothness = 0.99,    -- SNAP quando muito perto
    FOV = 1000,               -- FOV grande padr√£o
    MaxDistance = 2000,       -- Dist√¢ncia m√°xima
    TargetPart = "Head",
    WallCheck = false,
    MagnetMode = false,       -- Modo √≠m√£
    LockTarget = false,       -- Travar alvo
    PriorityMode = "FOV",     -- "FOV" ou "Distance"
    MaxFOVForDistance = 800   -- FOV m√°ximo quando em modo Distance
}

-- Vari√°veis de controle
local ESPObjects = {}
local CurrentTarget = nil
local LockedTarget = nil
local FOV_Circle = nil
local Connection = nil
local IsShooting = false
local LastClickTime = 0
local IsPanelVisible = true
local IsDraggingSlider = false
local ScreenGui = nil

-- Atualizar refer√™ncias (da v2)
local function UpdateReferences()
    LocalPlayer = Players.LocalPlayer
    if LocalPlayer then
        Mouse = LocalPlayer:GetMouse()
    end
    Camera = Workspace.CurrentCamera
end

-- Criar ESP (mesclado v1+v2)
local function CreateESP(player)
    if player == LocalPlayer then return end
    if ESPObjects[player] then RemoveESP(player) end
    
    local drawings = {}
    
    -- Box
    drawings.Box = Drawing.new("Square")
    drawings.Box.Visible = false
    drawings.Box.Color = ESP.BoxColor
    drawings.Box.Thickness = 2
    drawings.Box.Filled = false
    drawings.Box.Transparency = 1
    
    -- Nome
    drawings.Name = Drawing.new("Text")
    drawings.Name.Visible = false
    drawings.Name.Color = ESP.TextColor
    drawings.Name.Size = ESP.TextSize
    drawings.Name.Center = true
    drawings.Name.Outline = true
    drawings.Name.OutlineColor = Color3.fromRGB(0, 0, 0)
    
    -- Dist√¢ncia
    drawings.Distance = Drawing.new("Text")
    drawings.Distance.Visible = false
    drawings.Distance.Color = ESP.TextColor
    drawings.Distance.Size = ESP.TextSize - 2
    drawings.Distance.Center = true
    drawings.Distance.Outline = true
    drawings.Distance.OutlineColor = Color3.fromRGB(0, 0, 0)
    
    -- Tracer/Line (da v2)
    drawings.Line = Drawing.new("Line")
    drawings.Line.Visible = false
    drawings.Line.Color = Color3.fromRGB(255, 0, 0)
    drawings.Line.Thickness = 2
    
    ESPObjects[player] = drawings
end

local function RemoveESP(player)
    if ESPObjects[player] then
        for _, drawing in pairs(ESPObjects[player]) do
            if drawing then drawing:Remove() end
        end
        ESPObjects[player] = nil
    end
end

-- Verificar visibilidade (Wall Check)
local function IsVisible(targetPosition)
    if not AimAssist.WallCheck then return true end
    if not LocalPlayer.Character then return false end
    
    local origin = Camera.CFrame.Position
    local direction = (targetPosition - origin).Unit * (targetPosition - origin).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local result = Workspace:Raycast(origin, direction, raycastParams)
    return result == nil
end

-- GetClosestPlayerByDistance (da v1 - avan√ßado)
local function GetClosestPlayerByDistance()
    if not LocalPlayer.Character then return nil end
    local myHumanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    local myRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or LocalPlayer.Character:FindFirstChild("Torso")
    if not myHumanoid or not myRoot or myHumanoid.Health <= 0 then return nil end
    
    local closestPlayer = nil
    local shortestDistance = AimAssist.MaxDistance
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    -- Verifica target travado
    if AimAssist.LockTarget and LockedTarget and LockedTarget.Character then
        local targetPart = LockedTarget.Character:FindFirstChild(AimAssist.TargetPart)
        local humanoid = LockedTarget.Character:FindFirstChildOfClass("Humanoid")
        if targetPart and humanoid and humanoid.Health > 0 then
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if onScreen and (Vector2.new(screenPos.X, screenPos.Y) - centerScreen).Magnitude <= AimAssist.MaxFOVForDistance then
                return LockedTarget
            end
        end
        LockedTarget = nil
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if AimAssist.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local targetPart = character:FindFirstChild(AimAssist.TargetPart)
        
        if not humanoid or not targetPart or humanoid.Health <= 0 then continue end
        
        local distance3D = (myRoot.Position - targetPart.Position).Magnitude
        if distance3D > AimAssist.MaxDistance then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        local screenDistance = (Vector2.new(screenPos.X, screenPos.Y) - centerScreen).Magnitude
        if screenDistance > AimAssist.MaxFOVForDistance then continue end
        
        if not IsVisible(targetPart.Position) then continue end
        
        if distance3D < shortestDistance then
            shortestDistance = distance3D
            closestPlayer = player
        end
    end
    
    if AimAssist.LockTarget and closestPlayer then
        LockedTarget = closestPlayer
    end
    
    return closestPlayer
end

-- GetClosestPlayerByFOV (da v1 - avan√ßado)
local function GetClosestPlayerByFOV()
    if not LocalPlayer.Character then return nil end
    local myHumanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    local myRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or LocalPlayer.Character:FindFirstChild("Torso")
    if not myHumanoid or not myRoot or myHumanoid.Health <= 0 then return nil end
    
    local closestPlayer = nil
    local shortestScreenDistance = AimAssist.FOV
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    -- Verifica target travado
    if AimAssist.LockTarget and LockedTarget and LockedTarget.Character then
        local targetPart = LockedTarget.Character:FindFirstChild(AimAssist.TargetPart)
        local humanoid = LockedTarget.Character:FindFirstChildOfClass("Humanoid")
        if targetPart and humanoid and humanoid.Health > 0 then
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if onScreen then return LockedTarget end
        end
        LockedTarget = nil
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if AimAssist.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local targetPart = character:FindFirstChild(AimAssist.TargetPart)
        
        if not humanoid or not targetPart or humanoid.Health <= 0 then continue end
        
        local distance3D = (myRoot.Position - targetPart.Position).Magnitude
        if distance3D > AimAssist.MaxDistance then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        if not IsVisible(targetPart.Position) then continue end
        
        local screenDistance = (Vector2.new(screenPos.X, screenPos.Y) - centerScreen).Magnitude
        if screenDistance < shortestScreenDistance then
            shortestScreenDistance = screenDistance
            closestPlayer = player
        end
    end
    
    if AimAssist.LockTarget and closestPlayer then
        LockedTarget = closestPlayer
    end
    
    return closestPlayer
end

-- GetClosestPlayer unificado (da v1)
local function GetClosestPlayer()
    if AimAssist.PriorityMode == "Distance" then
        return GetClosestPlayerByDistance()
    else
        return GetClosestPlayerByFOV()
    end
end

-- ApplyAimAssist ULTRA FORTE (da v2 com melhorias da v1)
local function ApplyAimAssist()
    UpdateReferences()
    
    local shouldApply = AimAssist.AlwaysOn or (AimAssist.Enabled and (not AimAssist.ShootToActivate or IsShooting))
    
    if not shouldApply then 
        CurrentTarget = nil
        return 
    end
    
    if not LocalPlayer.Character then return end
    local myHumanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not myHumanoid or myHumanoid.Health <= 0 then return end
    
    CurrentTarget = GetClosestPlayer()
    
    if CurrentTarget and CurrentTarget.Character then
        local targetPart = CurrentTarget.Character:FindFirstChild(AimAssist.TargetPart)
        if targetPart then
            local targetPos = targetPart.Position
            if AimAssist.TargetPart == "Head" then
                targetPos = targetPos + Vector3.new(0, 0.2, 0)
            end
            
            local cameraCF = Camera.CFrame
            local targetCF = CFrame.new(cameraCF.Position, targetPos)
            
            local screenPos = Camera:WorldToViewportPoint(targetPos)
            local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            local distanceFromCenter = (Vector2.new(screenPos.X, screenPos.Y) - centerScreen).Magnitude
            
            -- Sistema de suavidade ULTRA FORTE (da v2)
            local smoothValue
            if distanceFromCenter < 30 then
                smoothValue = AimAssist.SnapSmoothness  -- 0.99 = SNAP instant√¢neo
            elseif distanceFromCenter < 100 then
                smoothValue = 0.95
            elseif AimAssist.MagnetMode then
                smoothValue = 0.9
            else
                smoothValue = AimAssist.Smoothness      -- 0.95 padr√£o
            end
            
            Camera.CFrame = cameraCF:Lerp(targetCF, smoothValue)
        end
    else
        LockedTarget = nil
    end
end

-- UpdateESP mesclado (v1 + v2)
local function UpdateESP()
    UpdateReferences()
    
    if not LocalPlayer.Character then return end
    local myRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or LocalPlayer.Character:FindFirstChild("Torso")
    if not myRoot then return end
    
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    -- Atualizar FOV Circle com cores din√¢micas (da v1)
    if FOV_Circle then
        local showCircle = AimAssist.AlwaysOn or (AimAssist.Enabled and (IsShooting or not AimAssist.ShootToActivate))
        FOV_Circle.Visible = showCircle
        FOV_Circle.Position = centerScreen
        
        if AimAssist.PriorityMode == "Distance" then
            FOV_Circle.Radius = AimAssist.MaxFOVForDistance
            FOV_Circle.Color = Color3.fromRGB(0, 255, 255)  -- Ciano para Distance
        else
            FOV_Circle.Radius = AimAssist.FOV
            FOV_Circle.Color = Color3.fromRGB(255, 0, 0)    -- Vermelho para FOV
        end
        
        if CurrentTarget and IsShooting then
            FOV_Circle.Thickness = 3
            FOV_Circle.Color = Color3.fromRGB(255, 0, 0)
        elseif CurrentTarget then
            FOV_Circle.Thickness = 2
            FOV_Circle.Color = Color3.fromRGB(255, 255, 0)
        else
            FOV_Circle.Thickness = 1
            FOV_Circle.Color = Color3.fromRGB(100, 100, 100)
        end
    end
    
    for player, drawings in pairs(ESPObjects) do
        if not ESP.Enabled then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        local character = player.Character
        if not character then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso")
        
        if not humanoid or not rootPart or humanoid.Health <= 0 then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        if ESP.TeamCheck and player.Team == LocalPlayer.Team then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        local rootPosition, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
        local distance = (myRoot.Position - rootPart.Position).Magnitude
        
        if not onScreen or distance > ESP.MaxDistance then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        local size = math.clamp(2000 / rootPosition.Z, 10, 200)
        local width = size * 0.6
        local height = size * 1.2
        
        drawings.Box.Size = Vector2.new(width, height)
        drawings.Box.Position = Vector2.new(rootPosition.X - width/2, rootPosition.Y - height/2)
        drawings.Box.Visible = true
        
        -- Estilo do alvo atual (mesclado v1+v2)
        if player == CurrentTarget then
            if IsShooting then
                drawings.Box.Color = Color3.fromRGB(255, 0, 0)
                drawings.Box.Thickness = 5
            else
                drawings.Box.Color = AimAssist.MagnetMode and Color3.fromRGB(255, 0, 255) or Color3.fromRGB(255, 255, 0)
                drawings.Box.Thickness = 3
            end
            drawings.Box.Filled = true
            drawings.Box.Transparency = 0.3
            
            -- Line para o centro (da v2)
            drawings.Line.From = centerScreen
            drawings.Line.To = Vector2.new(rootPosition.X, rootPosition.Y)
            drawings.Line.Visible = true
            drawings.Line.Color = IsShooting and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 255, 0)
        else
            drawings.Box.Color = ESP.BoxColor
            drawings.Box.Thickness = 2
            drawings.Box.Filled = false
            drawings.Box.Transparency = 1
            drawings.Line.Visible = false
        end
        
        -- Nome com indicadores
        drawings.Name.Text = player.Name .. (player == CurrentTarget and (IsShooting and " [FIRING]" or " [TARGET]") or "")
        drawings.Name.Position = Vector2.new(rootPosition.X, rootPosition.Y - height/2 - 15)
        drawings.Name.Visible = true
        drawings.Name.Color = (player == CurrentTarget) and (IsShooting and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 255, 0)) or ESP.TextColor
        drawings.Name.Size = (player == CurrentTarget) and 16 or ESP.TextSize
        
        -- Dist√¢ncia
        drawings.Distance.Text = math.floor(distance) .. "m"
        drawings.Distance.Position = Vector2.new(rootPosition.X, rootPosition.Y + height/2 + 5)
        drawings.Distance.Visible = true
    end
end

-- CRIAR INTERFACE (baseada na v2 com elementos da v1)
local function CreateGUI()
    local parent = gethui and gethui() or LocalPlayer:WaitForChild("PlayerGui")
    
    ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "ESPMenu_" .. tostring(math.random(1000, 9999))
    ScreenGui.Parent = parent
    ScreenGui.ResetOnSpawn = false
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local MainFrame = Instance.new("Frame")
    MainFrame.Size = UDim2.new(0, 280, 0, 580)  -- Aumentado para caber bot√£o de prioridade
    MainFrame.Position = UDim2.new(0, 20, 0, 20)
    MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    MainFrame.BorderSizePixel = 0
    MainFrame.Active = true
    MainFrame.Draggable = true
    MainFrame.Parent = ScreenGui

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 8)
    UICorner.Parent = MainFrame

    -- T√≠tulo
    local Title = Instance.new("TextLabel")
    Title.Size = UDim2.new(1, 0, 0, 35)
    Title.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
    Title.BorderSizePixel = 0
    Title.Text = "üî• AIM ASSIST ULTRA üî•"
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.TextSize = 18
    Title.Font = Enum.Font.GothamBold
    Title.Parent = MainFrame

    local TitleCorner = Instance.new("UICorner")
    TitleCorner.CornerRadius = UDim.new(0, 8)
    TitleCorner.Parent = Title

    -- Fun√ß√£o bot√£o
    local function CreateButton(name, posY, color, textSize)
        local Button = Instance.new("TextButton")
        Button.Size = UDim2.new(0.9, 0, 0, 28)
        Button.Position = UDim2.new(0.05, 0, 0, posY)
        Button.BackgroundColor3 = color or Color3.fromRGB(70, 70, 70)
        Button.BorderSizePixel = 0
        Button.Text = name .. ": OFF"
        Button.TextColor3 = Color3.fromRGB(255, 255, 255)
        Button.TextSize = textSize or 11
        Button.Font = Enum.Font.GothamBold
        Button.Parent = MainFrame
        
        local Corner = Instance.new("UICorner")
        Corner.CornerRadius = UDim.new(0, 6)
        Corner.Parent = Button
        
        return Button
    end

    -- Bot√µes principais
    local ToggleESP = CreateButton("ESP", 40, Color3.fromRGB(200, 50, 50))
    local ToggleAim = CreateButton("AIM ASSIST", 72, Color3.fromRGB(200, 50, 50), 12)
    local ToggleShootMode = CreateButton("ON SHOOT ONLY", 104, Color3.fromRGB(0, 100, 200))
    local ToggleMagnet = CreateButton("MAGNET MODE", 136, Color3.fromRGB(150, 0, 150))
    local ToggleLock = CreateButton("LOCK TARGET", 168, Color3.fromRGB(100, 100, 0))
    local ToggleTeamESP = CreateButton("Team Check ESP", 200, Color3.fromRGB(70, 70, 70))
    local ToggleTeamAim = CreateButton("Team Check Aim", 232, Color3.fromRGB(50, 150, 50))
    local ToggleWallCheck = CreateButton("Wall Check", 264, Color3.fromRGB(70, 70, 70))
    
    -- NOVO: Bot√£o de Prioridade (da v1)
    local TogglePriority = CreateButton("PRIORITY: FOV", 296, Color3.fromRGB(0, 150, 255), 11)
    
    -- Bot√£o esconder painel
    local TogglePanel = CreateButton("HIDE PANEL", 328, Color3.fromRGB(100, 100, 100))
    TogglePanel.Text = "HIDE PANEL üëÅÔ∏è"

    -- SLIDER DE FOV (da v2)
    local SliderContainer = Instance.new("Frame")
    SliderContainer.Size = UDim2.new(0.9, 0, 0, 50)
    SliderContainer.Position = UDim2.new(0.05, 0, 0, 360)
    SliderContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    SliderContainer.BorderSizePixel = 0
    SliderContainer.Parent = MainFrame

    local SliderCorner = Instance.new("UICorner")
    SliderCorner.CornerRadius = UDim.new(0, 6)
    SliderCorner.Parent = SliderContainer

    local FOVLabel = Instance.new("TextLabel")
    FOVLabel.Size = UDim2.new(1, 0, 0, 20)
    FOVLabel.Position = UDim2.new(0, 0, 0, 5)
    FOVLabel.BackgroundTransparency = 1
    FOVLabel.Text = "FOV: 1000"
    FOVLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
    FOVLabel.TextSize = 12
    FOVLabel.Font = Enum.Font.GothamBold
    FOVLabel.Parent = SliderContainer

    local SliderBG = Instance.new("Frame")
    SliderBG.Size = UDim2.new(0.9, 0, 0, 8)
    SliderBG.Position = UDim2.new(0.05, 0, 0, 28)
    SliderBG.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    SliderBG.BorderSizePixel = 0
    SliderBG.Parent = SliderContainer

    local SliderBGCorner = Instance.new("UICorner")
    SliderBGCorner.CornerRadius = UDim.new(0, 4)
    SliderBGCorner.Parent = SliderBG

    local SliderFill = Instance.new("Frame")
    SliderFill.Size = UDim2.new(0.666, 0, 1, 0)  -- 1000/1500 = ~0.666
    SliderFill.Position = UDim2.new(0, 0, 0, 0)
    SliderFill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    SliderFill.BorderSizePixel = 0
    SliderFill.Parent = SliderBG

    local SliderFillCorner = Instance.new("UICorner")
    SliderFillCorner.CornerRadius = UDim.new(0, 4)
    SliderFillCorner.Parent = SliderFill

    local SliderKnob = Instance.new("TextButton")
    SliderKnob.Size = UDim2.new(0, 16, 0, 16)
    SliderKnob.Position = UDim2.new(0.666, -8, 0.5, -8)
    SliderKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    SliderKnob.BorderSizePixel = 0
    SliderKnob.Text = ""
    SliderKnob.Parent = SliderBG

    local SliderKnobCorner = Instance.new("UICorner")
    SliderKnobCorner.CornerRadius = UDim.new(1, 0)
    SliderKnobCorner.Parent = SliderKnob

    local MinLabel = Instance.new("TextLabel")
    MinLabel.Size = UDim2.new(0, 30, 0, 15)
    MinLabel.Position = UDim2.new(0.05, 0, 0, 38)
    MinLabel.BackgroundTransparency = 1
    MinLabel.Text = "10"
    MinLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    MinLabel.TextSize = 9
    MinLabel.Font = Enum.Font.Gotham
    MinLabel.Parent = SliderContainer

    local MaxLabel = Instance.new("TextLabel")
    MaxLabel.Size = UDim2.new(0, 30, 0, 15)
    MaxLabel.Position = UDim2.new(0.85, 0, 0, 38)
    MaxLabel.BackgroundTransparency = 1
    MaxLabel.Text = "1500"
    MaxLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    MaxLabel.TextSize = 9
    MaxLabel.Font = Enum.Font.Gotham
    MaxLabel.Parent = SliderContainer

    -- Status e Info
    local StatusLabel = Instance.new("TextLabel")
    StatusLabel.Size = UDim2.new(0.9, 0, 0, 20)
    StatusLabel.Position = UDim2.new(0.05, 0, 0, 414)
    StatusLabel.BackgroundTransparency = 1
    StatusLabel.Text = "Status: Esperando tiro..."
    StatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
    StatusLabel.TextSize = 10
    StatusLabel.Font = Enum.Font.GothamBold
    StatusLabel.Parent = MainFrame

    local ModeLabel = Instance.new("TextLabel")
    ModeLabel.Size = UDim2.new(0.9, 0, 0, 30)
    ModeLabel.Position = UDim2.new(0.05, 0, 0, 437)
    ModeLabel.BackgroundTransparency = 1
    ModeLabel.Text = "MODO: Clique esquerdo para ativar aim"
    ModeLabel.TextColor3 = Color3.fromRGB(0, 200, 255)
    ModeLabel.TextSize = 10
    ModeLabel.Font = Enum.Font.Gotham
    ModeLabel.TextWrapped = true
    ModeLabel.Parent = MainFrame
    
    -- Label de prioridade (da v1)
    local PriorityLabel = Instance.new("TextLabel")
    PriorityLabel.Size = UDim2.new(0.9, 0, 0, 20)
    PriorityLabel.Position = UDim2.new(0.05, 0, 0, 467)
    PriorityLabel.BackgroundTransparency = 1
    PriorityLabel.Text = "üéØ Alvo: Mais central (FOV)"
    PriorityLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
    PriorityLabel.TextSize = 10
    PriorityLabel.Font = Enum.Font.GothamBold
    PriorityLabel.Parent = MainFrame

    local WarningLabel = Instance.new("TextLabel")
    WarningLabel.Size = UDim2.new(0.9, 0, 0, 25)
    WarningLabel.Position = UDim2.new(0.05, 0, 0, 545)
    WarningLabel.BackgroundTransparency = 1
    WarningLabel.Text = "‚ö†Ô∏è ULTRA FORTE | Smooth: 0.95"
    WarningLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
    WarningLabel.TextSize = 10
    WarningLabel.Font = Enum.Font.Gotham
    WarningLabel.Parent = MainFrame

    -- FUN√á√ÉO DO SLIDER
    local function UpdateSlider(input)
        local relativeX = math.clamp((input.Position.X - SliderBG.AbsolutePosition.X) / SliderBG.AbsoluteSize.X, 0, 1)
        local newFOV = math.floor(10 + (relativeX * 1490))
        
        if AimAssist.PriorityMode == "Distance" then
            AimAssist.MaxFOVForDistance = newFOV
            FOVLabel.Text = "Max FOV Dist: " .. newFOV .. (newFOV >= 1400 and " (MAX)" or newFOV <= 20 and " (MIN)" or "")
        else
            AimAssist.FOV = newFOV
            FOVLabel.Text = "FOV: " .. newFOV .. (newFOV >= 1400 and " (MAX)" or newFOV <= 20 and " (MIN)" or "")
        end
        
        SliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
        SliderKnob.Position = UDim2.new(relativeX, -8, 0.5, -8)
        
        if FOV_Circle then 
            if AimAssist.PriorityMode == "Distance" then
                FOV_Circle.Radius = AimAssist.MaxFOVForDistance
            else
                FOV_Circle.Radius = newFOV 
            end
        end
    end

    -- Eventos do Slider
    SliderKnob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            IsDraggingSlider = true
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if IsDraggingSlider and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            UpdateSlider(input)
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            IsDraggingSlider = false
        end
    end)

    SliderBG.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            UpdateSlider(input)
        end
    end)

    -- FUN√á√ïES DOS BOT√ïES
    ToggleESP.MouseButton1Click:Connect(function()
        ESP.Enabled = not ESP.Enabled
        ToggleESP.Text = "ESP: " .. (ESP.Enabled and "ON" or "OFF")
        ToggleESP.BackgroundColor3 = ESP.Enabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(200, 50, 50)
    end)

    ToggleAim.MouseButton1Click:Connect(function()
        AimAssist.Enabled = not AimAssist.Enabled
        ToggleAim.Text = "AIM ASSIST: " .. (AimAssist.Enabled and "ON üî•" or "OFF")
        ToggleAim.BackgroundColor3 = AimAssist.Enabled and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(200, 50, 50)
        if AimAssist.Enabled then
            Title.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            wait(0.2)
            Title.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
        end
    end)

    ToggleShootMode.MouseButton1Click:Connect(function()
        AimAssist.ShootToActivate = not AimAssist.ShootToActivate
        if AimAssist.ShootToActivate then
            ToggleShootMode.Text = "ON SHOOT ONLY: ON üéØ"
            ToggleShootMode.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
            ModeLabel.Text = "MODO: Clique esquerdo para ativar aim"
            ModeLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
        else
            ToggleShootMode.Text = "ALWAYS ON: ON ‚ö°"
            ToggleShootMode.BackgroundColor3 = Color3.fromRGB(255, 100, 0)
            ModeLabel.Text = "MODO: Sempre ativo quando ligado"
            ModeLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
        end
    end)

    ToggleMagnet.MouseButton1Click:Connect(function()
        AimAssist.MagnetMode = not AimAssist.MagnetMode
        ToggleMagnet.Text = "MAGNET: " .. (AimAssist.MagnetMode and "ON üß≤" or "OFF")
        ToggleMagnet.BackgroundColor3 = AimAssist.MagnetMode and Color3.fromRGB(255, 0, 255) or Color3.fromRGB(150, 0, 150)
    end)

    ToggleLock.MouseButton1Click:Connect(function()
        AimAssist.LockTarget = not AimAssist.LockTarget
        ToggleLock.Text = "LOCK: " .. (AimAssist.LockTarget and "ON üîí" or "OFF")
        ToggleLock.BackgroundColor3 = AimAssist.LockTarget and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(100, 100, 0)
    end)

    ToggleTeamESP.MouseButton1Click:Connect(function()
        ESP.TeamCheck = not ESP.TeamCheck
        ToggleTeamESP.Text = "Team ESP: " .. (ESP.TeamCheck and "ON" or "OFF")
        ToggleTeamESP.BackgroundColor3 = ESP.TeamCheck and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(70, 70, 70)
    end)

    ToggleTeamAim.MouseButton1Click:Connect(function()
        AimAssist.TeamCheck = not AimAssist.TeamCheck
        ToggleTeamAim.Text = "Team Aim: " .. (AimAssist.TeamCheck and "ON" or "OFF")
        ToggleTeamAim.BackgroundColor3 = AimAssist.TeamCheck and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(50, 150, 50)
    end)

    ToggleWallCheck.MouseButton1Click:Connect(function()
        AimAssist.WallCheck = not AimAssist.WallCheck
        ToggleWallCheck.Text = "Wall Check: " .. (AimAssist.WallCheck and "ON" or "OFF")
        ToggleWallCheck.BackgroundColor3 = AimAssist.WallCheck and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(70, 70, 70)
    end)
    
    -- Bot√£o de Prioridade (da v1)
    TogglePriority.MouseButton1Click:Connect(function()
        if AimAssist.PriorityMode == "FOV" then
            AimAssist.PriorityMode = "Distance"
            TogglePriority.Text = "PRIORITY: DISTANCE"
            TogglePriority.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
            PriorityLabel.Text = "üéØ Alvo: Mais pr√≥ximo (3D)"
            PriorityLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
            -- Atualiza slider para MaxFOVForDistance
            local relativeX = math.clamp((AimAssist.MaxFOVForDistance - 10) / 1490, 0, 1)
            SliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
            SliderKnob.Position = UDim2.new(relativeX, -8, 0.5, -8)
            FOVLabel.Text = "Max FOV Dist: " .. AimAssist.MaxFOVForDistance
        else
            AimAssist.PriorityMode = "FOV"
            TogglePriority.Text = "PRIORITY: FOV (CENTER)"
            TogglePriority.BackgroundColor3 = Color3.fromRGB(255, 100, 0)
            PriorityLabel.Text = "üéØ Alvo: Mais central (tela)"
            PriorityLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
            -- Atualiza slider para FOV
            local relativeX = math.clamp((AimAssist.FOV - 10) / 1490, 0, 1)
            SliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
            SliderKnob.Position = UDim2.new(relativeX, -8, 0.5, -8)
            FOVLabel.Text = "FOV: " .. AimAssist.FOV
        end
    end)

    -- Fun√ß√£o esconder/mostrar painel (da v2)
    TogglePanel.MouseButton1Click:Connect(function()
        IsPanelVisible = not IsPanelVisible
        
        local elementsToToggle = {
            ToggleESP, ToggleAim, ToggleShootMode, ToggleMagnet, 
            ToggleLock, ToggleTeamESP, ToggleTeamAim, ToggleWallCheck, TogglePriority,
            SliderContainer, StatusLabel, ModeLabel, PriorityLabel, WarningLabel
        }
        
        for _, element in ipairs(elementsToToggle) do
            if element and element:IsA("GuiObject") then
                element.Visible = IsPanelVisible
            end
        end
        
        if IsPanelVisible then
            MainFrame.Size = UDim2.new(0, 280, 0, 580)
            TogglePanel.Position = UDim2.new(0.05, 0, 0, 328)
            TogglePanel.Text = "HIDE PANEL üëÅÔ∏è"
            TogglePanel.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
            Title.Text = "üî• AIM ASSIST ULTRA üî•"
        else
            MainFrame.Size = UDim2.new(0, 280, 0, 70)
            TogglePanel.Position = UDim2.new(0.05, 0, 0, 40)
            TogglePanel.Text = "SHOW PANEL üëÅÔ∏è‚Äçüó®Ô∏è"
            TogglePanel.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
            Title.Text = "üî• MENU üî•"
        end
    end)

    -- Loop de atualiza√ß√£o do Status
    RunService.RenderStepped:Connect(function()
        if CurrentTarget and IsShooting then
            StatusLabel.Text = "Status: ATIRANDO em " .. CurrentTarget.Name
            StatusLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
        elseif CurrentTarget then
            StatusLabel.Text = "Status: üéØ " .. CurrentTarget.Name
            StatusLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
        elseif AimAssist.Enabled and AimAssist.ShootToActivate then
            StatusLabel.Text = "Status: Esperando tiro..."
            StatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
        elseif AimAssist.Enabled then
            StatusLabel.Text = "Status: Sempre Ativo"
            StatusLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
        else
            StatusLabel.Text = "Status: Desativado"
            StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
        end
    end)
end

-- FOV Circle (da v2)
FOV_Circle = Drawing.new("Circle")
FOV_Circle.Visible = false
FOV_Circle.Thickness = 2
FOV_Circle.NumSides = 64
FOV_Circle.Radius = AimAssist.FOV
FOV_Circle.Filled = false
FOV_Circle.Transparency = 0.3
FOV_Circle.Color = Color3.fromRGB(255, 0, 0)

-- Loop principal (da v2)
if Connection then Connection:Disconnect() end
Connection = RunService.RenderStepped:Connect(function()
    pcall(function()
        ApplyAimAssist()
        UpdateESP()
    end)
end)

-- Eventos de jogadores
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        CreateESP(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    wait(1)
    CreateESP(player)
end)

Players.PlayerRemoving:Connect(RemoveESP)

-- Sistema de detec√ß√£o de tiro ULTRA (da v2)
Mouse.Button1Down:Connect(function()
    IsShooting = true
    LastClickTime = tick()
end)

Mouse.Button1Up:Connect(function()
    IsShooting = false
    LockedTarget = nil
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        IsShooting = true
        LastClickTime = tick()
    end
    
    if input.UserInputType == Enum.UserInputType.Touch then
        IsShooting = true
        LastClickTime = tick()
    end
    
    if input.KeyCode == Enum.KeyCode.Space or input.KeyCode == Enum.KeyCode.Q then
        IsShooting = true
        LastClickTime = tick()
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        IsShooting = false
        LockedTarget = nil
    end
    
    if input.UserInputType == Enum.UserInputType.Touch then
        IsShooting = false
        LockedTarget = nil
    end
    
    if input.KeyCode == Enum.KeyCode.Space or input.KeyCode == Enum.KeyCode.Q then
        IsShooting = false
        LockedTarget = nil
    end
end)

-- Check cont√≠nuo (da v2)
spawn(function()
    while wait(0.05) do
        if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
            if not IsShooting then
                IsShooting = true
            end
        else
            if IsShooting then
                IsShooting = false
                LockedTarget = nil
            end
        end
        
        if IsShooting and (tick() - LastClickTime) > 3 then
            IsShooting = false
            LockedTarget = nil
        end
    end
end)

-- Teclas de atalho (da v2)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    -- Insert para esconder/mostrar painel
    if input.KeyCode == Enum.KeyCode.Insert then
        if ScreenGui and ScreenGui:FindFirstChildOfClass("Frame") then
            local mainFrame = ScreenGui:FindFirstChildOfClass("Frame")
            local toggleBtn = mainFrame:FindFirstChild("TextButton", 9) -- Aproximadamente o bot√£o de toggle
            if toggleBtn then
                toggleBtn.MouseButton1Click:Fire()
            end
        end
    end
    
    -- F para ativar aim temporariamente
    if input.KeyCode == Enum.KeyCode.F then
        if AimAssist.ShootToActivate then
            IsShooting = true
        else
            AimAssist.Enabled = true
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.F then
        if AimAssist.ShootToActivate then
            IsShooting = false
            LockedTarget = nil
        else
            AimAssist.Enabled = false
            LockedTarget = nil
        end
    end
end)

-- Respawn handler
LocalPlayer.CharacterAdded:Connect(function()
    wait(2)
    UpdateReferences()
    for _, player in pairs(Players:GetPlayers()) do
        if not ESPObjects[player] then
            CreateESP(player)
        end
    end
end)

-- Criar GUI
CreateGUI()

-- Inicializa√ß√£o
print("=== üî• AIM ASSIST ULTRA - VERS√ÉO FINAL MESCLADA üî• ===")
print("FOR√áA: ULTRA (0.95 smoothness / 0.99 snap)")
print("MODO: " .. (AimAssist.ShootToActivate and "ATIVA AO ATIRAR" or "SEMPRE ATIVO"))
print("PRIORIDADE: " .. AimAssist.PriorityMode)
print("TECLAS: [Insert] Esconder/Mostrar | [F] Aim Tempor√°rio | [Q/Espa√ßo] Atirar")
print("SLIDER FOV: 10 a 1500 (arraste para ajustar)")
