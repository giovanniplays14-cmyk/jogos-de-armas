-- ESP Script com Aim Assist ULTRA FORTE - ATIVA AO ATIRAR (CORRIGIDO)
-- Criado para Roblox
-- üéØ NOVO: Prioriza oponente mais pr√≥ximo por dist√¢ncia 3D, n√£o por FOV
-- üëª NOVO: Modo "Invis√≠vel" - Esconde visualmente (client-side apenas)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Vari√°veis globais
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

-- Configura√ß√µes
local ESP = {
    Enabled = false,
    TeamCheck = false,
    MaxDistance = 3000,
    BoxColor = Color3.fromRGB(255, 0, 0),
    TextColor = Color3.fromRGB(255, 255, 255),
    TextSize = 14
}

-- Configura√ß√µes do Aim Assist
local AimAssist = {
    Enabled = false,
    AlwaysOn = false,
    ShootToActivate = true,
    TeamCheck = true,
    Smoothness = 0.95,
    SnapSmoothness = 0.99,
    FOV = 1000,
    MaxDistance = 2000,
    TargetPart = "Head",
    WallCheck = false,
    MagnetMode = false,
    LockTarget = false,
    PriorityMode = "Distance",
    MaxFOVForDistance = 800
}

-- üëª Configura√ß√µes de Invisibilidade (CLIENT-SIDE APENAS)
local Invisibility = {
    Enabled = false,
    OriginalTransparency = {},
    InvisibleTransparency = 1, -- 100% invis√≠vel para voc√™
    HideName = true,
    -- üî¥ AVISO: Os m√©todos abaixo s√£o tentativas, n√£o garantem invisibilidade real
    AttemptServerSide = false, -- Tenta m√©todos avan√ßados (pode n√£o funcionar/ser detectado)
    AntiHitbox = false         -- Tenta diminuir hitbox (arriscado)
}

-- Vari√°veis de controle
local ESPObjects = {}
local CurrentTarget = nil
local LockedTarget = nil
local FOV_Circle = nil
local Connection = nil
local IsShooting = false
local LastClickTime = 0
local IsPanelVisible = true
local IsDraggingSlider = false
local InvisibilityConnection = nil
local OriginalCharacterProperties = {}

-- Atualizar refer√™ncias
local function UpdateReferences()
    LocalPlayer = Players.LocalPlayer
    if LocalPlayer then
        Mouse = LocalPlayer:GetMouse()
    end
    Camera = Workspace.CurrentCamera
end

-- üëª FUN√á√ÉO: Salvar propriedades originais
local function SaveOriginalTransparency(character)
    OriginalCharacterProperties[character] = {}
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            OriginalCharacterProperties[character][part] = {
                Transparency = part.Transparency,
                CastShadow = part.CastShadow,
                LocalTransparencyModifier = part.LocalTransparencyModifier,
                Size = part.Size,
                Massless = part.Massless
            }
        elseif part:IsA("Decal") or part:IsA("Texture") then
            OriginalCharacterProperties[character][part] = {
                Transparency = part.Transparency
            }
        elseif part:IsA("BillboardGui") then
            OriginalCharacterProperties[character][part] = {
                Enabled = part.Enabled
            }
        end
    end
end

-- üëª FUN√á√ÉO: Invisibilidade CLIENT-SIDE (s√≥ voc√™ n√£o v√™ seu personagem)
local function ApplyClientSideInvisibility()
    if not LocalPlayer.Character then return end
    
    local character = LocalPlayer.Character
    
    if not OriginalCharacterProperties[character] then
        SaveOriginalTransparency(character)
    end
    
    -- Torna tudo invis√≠vel na SUA tela apenas
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Transparency = 1
            part.CastShadow = false
            part.LocalTransparencyModifier = 1
        elseif part:IsA("Decal") or part:IsA("Texture") then
            part.Transparency = 1
        elseif part:IsA("BillboardGui") and Invisibility.HideName then
            part.Enabled = false
        elseif part:IsA("ParticleEmitter") or part:IsA("Trail") then
            part.Enabled = false
        elseif part:IsA("PointLight") or part:IsA("SpotLight") or part:IsA("SurfaceLight") then
            part.Enabled = false
        end
    end
    
    -- Esconde acess√≥rios
    for _, accessory in pairs(character:GetChildren()) do
        if accessory:IsA("Accessory") then
            local handle = accessory:FindFirstChild("Handle")
            if handle and handle:IsA("BasePart") then
                handle.Transparency = 1
                handle.CastShadow = false
                handle.LocalTransparencyModifier = 1
                for _, decal in pairs(handle:GetDescendants()) do
                    if decal:IsA("Decal") or decal:IsA("Texture") then
                        decal.Transparency = 1
                    end
                end
            end
        end
    end
    
    -- Esconde ferramentas
    for _, tool in pairs(character:GetChildren()) do
        if tool:IsA("Tool") then
            for _, part in pairs(tool:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.Transparency = 1
                    part.CastShadow = false
                    part.LocalTransparencyModifier = 1
                elseif part:IsA("Decal") or part:IsA("Texture") then
                    part.Transparency = 1
                end
            end
        end
    end
    
    -- Desativa highlight
    local highlight = character:FindFirstChildOfClass("Highlight")
    if highlight then
        highlight.Enabled = false
    end
end

-- üëª FUN√á√ÉO: Tentar invisibilidade SERVER-SIDE (experimental, provavelmente n√£o funciona)
local function AttemptServerSideInvisibility()
    -- üî¥ AVISO: Isso provavelmente N√ÉO FUNCIONA na maioria dos jogos
    -- e pode resultar em kick/ban. Use por sua conta e risco.
    
    local character = LocalPlayer.Character
    if not character then return end
    
    -- M√©todo 1: Tenta desativar render do personagem (s√≥ funciona localmente)
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            -- Torna massless (n√£o afeta f√≠sica, mas alguns jogos detectam)
            part.Massless = true
        end
    end
    
    -- M√©todo 2: Tenta manipular propriedades de rede (arriscado)
    pcall(function()
        -- Isso pode causar desync e kick
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                -- Tenta setar propriedade arquivada (pode crashar)
                part:SetAttribute("OriginalTransparency", part.Transparency)
            end
        end
    end)
    
    print("‚ö†Ô∏è Tentativa server-side aplicada (provavelmente n√£o funciona)")
end

-- üëª FUN√á√ÉO: Remover invisibilidade
local function RemoveInvisibility()
    if not LocalPlayer.Character then return end
    
    local character = LocalPlayer.Character
    
    if OriginalCharacterProperties[character] then
        for obj, properties in pairs(OriginalCharacterProperties[character]) do
            if obj and obj.Parent then
                for prop, value in pairs(properties) do
                    pcall(function()
                        obj[prop] = value
                    end)
                end
            end
        end
    else
        -- Fallback
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Transparency = 0
                part.CastShadow = true
                part.LocalTransparencyModifier = 0
            elseif part:IsA("Decal") or part:IsA("Texture") then
                part.Transparency = 0
            elseif part:IsA("BillboardGui") then
                part.Enabled = true
            elseif part:IsA("ParticleEmitter") or part:IsA("Trail") then
                part.Enabled = true
            elseif part:IsA("PointLight") or part:IsA("SpotLight") or part:IsA("SurfaceLight") then
                part.Enabled = true
            end
        end
    end
    
    local highlight = character:FindFirstChildOfClass("Highlight")
    if highlight then
        highlight.Enabled = true
    end
end

-- üëª FUN√á√ÉO: Toggle invisibilidade
local function ToggleInvisibility()
    Invisibility.Enabled = not Invisibility.Enabled
    
    if Invisibility.Enabled then
        ApplyClientSideInvisibility()
        
        -- Tenta m√©todos server-side se ativado (n√£o recomendado)
        if Invisibility.AttemptServerSide then
            AttemptServerSideInvisibility()
        end
        
        -- Mant√©m invis√≠vel
        if InvisibilityConnection then InvisibilityConnection:Disconnect() end
        InvisibilityConnection = RunService.RenderStepped:Connect(function()
            if Invisibility.Enabled and LocalPlayer.Character then
                for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") and part.Transparency < 1 then
                        part.Transparency = 1
                        part.CastShadow = false
                        part.LocalTransparencyModifier = 1
                    elseif (part:IsA("Decal") or part:IsA("Texture")) and part.Transparency < 1 then
                        part.Transparency = 1
                    end
                end
                
                -- Verifica ferramentas novas
                for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
                    if tool:IsA("Tool") and tool:FindFirstChild("Handle") then
                        local handle = tool:FindFirstChild("Handle")
                        if handle and handle:IsA("BasePart") and handle.Transparency < 1 then
                            for _, part in pairs(tool:GetDescendants()) do
                                if part:IsA("BasePart") then
                                    part.Transparency = 1
                                    part.CastShadow = false
                                    part.LocalTransparencyModifier = 1
                                elseif part:IsA("Decal") or part:IsA("Texture") then
                                    part.Transparency = 1
                                end
                            end
                        end
                    end
                end
            end
        end)
    else
        RemoveInvisibility()
        if InvisibilityConnection then
            InvisibilityConnection:Disconnect()
            InvisibilityConnection = nil
        end
    end
    
    return Invisibility.Enabled
end

-- Criar ESP
local function CreateESP(player)
    if player == LocalPlayer then return end
    if ESPObjects[player] then 
        for _, v in pairs(ESPObjects[player]) do
            if v then v:Remove() end
        end
    end
    
    local drawings = {}
    
    drawings.Box = Drawing.new("Square")
    drawings.Box.Visible = false
    drawings.Box.Color = ESP.BoxColor
    drawings.Box.Thickness = 2
    drawings.Box.Filled = false
    drawings.Box.Transparency = 1
    
    drawings.Name = Drawing.new("Text")
    drawings.Name.Visible = false
    drawings.Name.Color = ESP.TextColor
    drawings.Name.Size = ESP.TextSize
    drawings.Name.Center = true
    drawings.Name.Outline = true
    drawings.Name.OutlineColor = Color3.fromRGB(0, 0, 0)
    
    drawings.Distance = Drawing.new("Text")
    drawings.Distance.Visible = false
    drawings.Distance.Color = ESP.TextColor
    drawings.Distance.Size = ESP.TextSize - 2
    drawings.Distance.Center = true
    drawings.Distance.Outline = true
    drawings.Distance.OutlineColor = Color3.fromRGB(0, 0, 0)
    
    drawings.Line = Drawing.new("Line")
    drawings.Line.Visible = false
    drawings.Line.Color = Color3.fromRGB(255, 0, 0)
    drawings.Line.Thickness = 2
    
    ESPObjects[player] = drawings
end

local function RemoveESP(player)
    if ESPObjects[player] then
        for _, drawing in pairs(ESPObjects[player]) do
            if drawing then drawing:Remove() end
        end
        ESPObjects[player] = nil
    end
end

local function IsVisible(targetPosition)
    if not AimAssist.WallCheck then return true end
    if not LocalPlayer.Character then return false end
    
    local origin = Camera.CFrame.Position
    local direction = (targetPosition - origin).Unit * (targetPosition - origin).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local result = Workspace:Raycast(origin, direction, raycastParams)
    return result == nil
end

local function GetClosestPlayerByDistance()
    if not LocalPlayer.Character then return nil end
    local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    local myRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myHumanoid or not myRoot or myHumanoid.Health <= 0 then return nil end
    
    local closestPlayer = nil
    local shortestDistance = AimAssist.MaxDistance
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    if AimAssist.LockTarget and LockedTarget and LockedTarget.Character then
        local targetPart = LockedTarget.Character:FindFirstChild(AimAssist.TargetPart)
        local humanoid = LockedTarget.Character:FindFirstChild("Humanoid")
        if targetPart and humanoid and humanoid.Health > 0 then
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if onScreen then return LockedTarget end
        end
        LockedTarget = nil
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if AimAssist.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChild("Humanoid")
        local targetPart = character:FindFirstChild(AimAssist.TargetPart)
        
        if not humanoid or not targetPart or humanoid.Health <= 0 then continue end
        
        local distance3D = (myRoot.Position - targetPart.Position).Magnitude
        if distance3D > AimAssist.MaxDistance then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        local screenDistance = (Vector2.new(screenPos.X, screenPos.Y) - centerScreen).Magnitude
        if screenDistance > AimAssist.MaxFOVForDistance then continue end
        
        if not IsVisible(targetPart.Position) then continue end
        
        if distance3D < shortestDistance then
            shortestDistance = distance3D
            closestPlayer = player
        end
    end
    
    if AimAssist.LockTarget and closestPlayer then
        LockedTarget = closestPlayer
    end
    
    return closestPlayer
end

local function GetClosestPlayerByFOV()
    if not LocalPlayer.Character then return nil end
    local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    local myRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myHumanoid or not myRoot or myHumanoid.Health <= 0 then return nil end
    
    local closestPlayer = nil
    local shortestScreenDistance = AimAssist.FOV
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    if AimAssist.LockTarget and LockedTarget and LockedTarget.Character then
        local targetPart = LockedTarget.Character:FindFirstChild(AimAssist.TargetPart)
        local humanoid = LockedTarget.Character:FindFirstChild("Humanoid")
        if targetPart and humanoid and humanoid.Health > 0 then
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if onScreen then return LockedTarget end
        end
        LockedTarget = nil
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if AimAssist.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChild("Humanoid")
        local targetPart = character:FindFirstChild(AimAssist.TargetPart)
        
        if not humanoid or not targetPart or humanoid.Health <= 0 then continue end
        
        local distance3D = (myRoot.Position - targetPart.Position).Magnitude
        if distance3D > AimAssist.MaxDistance then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        if not IsVisible(targetPart.Position) then continue end
        
        local screenDistance = (Vector2.new(screenPos.X, screenPos.Y) - centerScreen).Magnitude
        if screenDistance < shortestScreenDistance then
            shortestScreenDistance = screenDistance
            closestPlayer = player
        end
    end
    
    if AimAssist.LockTarget and closestPlayer then
        LockedTarget = closestPlayer
    end
    
    return closestPlayer
end

local function GetClosestPlayer()
    if AimAssist.PriorityMode == "Distance" then
        return GetClosestPlayerByDistance()
    else
        return GetClosestPlayerByFOV()
    end
end

local function ApplyAimAssist()
    UpdateReferences()
    
    local shouldApply = AimAssist.AlwaysOn or (AimAssist.Enabled and (not AimAssist.ShootToActivate or IsShooting))
    
    if not shouldApply then 
        CurrentTarget = nil
        return 
    end
    
    if not LocalPlayer.Character then return end
    local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if not myHumanoid or myHumanoid.Health <= 0 then return end
    
    CurrentTarget = GetClosestPlayer()
    
    if CurrentTarget and CurrentTarget.Character then
        local targetPart = CurrentTarget.Character:FindFirstChild(AimAssist.TargetPart)
        if targetPart then
            local targetPos = targetPart.Position
            if AimAssist.TargetPart == "Head" then
                targetPos = targetPos + Vector3.new(0, 0.2, 0)
            end
            
            local cameraCF = Camera.CFrame
            local targetCF = CFrame.new(cameraCF.Position, targetPos)
            
            local screenPos = Camera:WorldToViewportPoint(targetPos)
            local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            local distanceFromCenter = (Vector2.new(screenPos.X, screenPos.Y) - centerScreen).Magnitude
            
            local smoothValue
            if distanceFromCenter < 30 then
                smoothValue = AimAssist.SnapSmoothness
            elseif distanceFromCenter < 100 then
                smoothValue = 0.95
            elseif AimAssist.MagnetMode then
                smoothValue = 0.9
            else
                smoothValue = AimAssist.Smoothness
            end
            
            Camera.CFrame = cameraCF:Lerp(targetCF, smoothValue)
        end
    else
        LockedTarget = nil
    end
end

local function UpdateESP()
    UpdateReferences()
    
    if not LocalPlayer.Character then return end
    local myRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    if FOV_Circle then
        local showCircle = AimAssist.AlwaysOn or (AimAssist.Enabled and (IsShooting or not AimAssist.ShootToActivate))
        FOV_Circle.Visible = showCircle
        FOV_Circle.Position = centerScreen
        
        if AimAssist.PriorityMode == "Distance" then
            FOV_Circle.Radius = AimAssist.MaxFOVForDistance
            FOV_Circle.Color = Color3.fromRGB(0, 255, 255)
        else
            FOV_Circle.Radius = AimAssist.FOV
            FOV_Circle.Color = Color3.fromRGB(255, 0, 0)
        end
        
        if CurrentTarget and IsShooting then
            FOV_Circle.Thickness = 3
            FOV_Circle.Color = Color3.fromRGB(255, 0, 0)
        elseif CurrentTarget then
            FOV_Circle.Thickness = 2
            FOV_Circle.Color = Color3.fromRGB(255, 255, 0)
        else
            FOV_Circle.Thickness = 1
            FOV_Circle.Color = Color3.fromRGB(100, 100, 100)
        end
    end
    
    for player, drawings in pairs(ESPObjects) do
        if not ESP.Enabled then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        local character = player.Character
        if not character then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        
        if not humanoid or not rootPart or humanoid.Health <= 0 then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        if ESP.TeamCheck and player.Team == LocalPlayer.Team then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        local rootPosition, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
        local distance = (myRoot.Position - rootPart.Position).Magnitude
        
        if not onScreen or distance > ESP.MaxDistance then
            for _, d in pairs(drawings) do d.Visible = false end
            continue
        end
        
        local size = math.clamp(2000 / rootPosition.Z, 10, 200)
        local width = size * 0.6
        local height = size * 1.2
        
        drawings.Box.Size = Vector2.new(width, height)
        drawings.Box.Position = Vector2.new(rootPosition.X - width/2, rootPosition.Y - height/2)
        drawings.Box.Visible = true
        
        if player == CurrentTarget then
            if IsShooting then
                drawings.Box.Color = Color3.fromRGB(255, 0, 0)
                drawings.Box.Thickness = 5
            else
                drawings.Box.Color = AimAssist.MagnetMode and Color3.fromRGB(255, 0, 255) or Color3.fromRGB(255, 255, 0)
                drawings.Box.Thickness = 3
            end
            drawings.Box.Filled = true
            drawings.Box.Transparency = 0.3
            
            drawings.Line.From = centerScreen
            drawings.Line.To = Vector2.new(rootPosition.X, rootPosition.Y)
            drawings.Line.Visible = true
            drawings.Line.Color = IsShooting and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 255, 0)
        else
            drawings.Box.Color = ESP.BoxColor
            drawings.Box.Thickness = 2
            drawings.Box.Filled = false
            drawings.Line.Visible = false
        end
        
        drawings.Name.Text = player.Name .. (player == CurrentTarget and (IsShooting and " [FIRING]" or " [TARGET]") or "")
        drawings.Name.Position = Vector2.new(rootPosition.X, rootPosition.Y - height/2 - 15)
        drawings.Name.Visible = true
        drawings.Name.Color = (player == CurrentTarget) and (IsShooting and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 255, 0)) or ESP.TextColor
        drawings.Name.Size = (player == CurrentTarget) and 16 or ESP.TextSize
        
        drawings.Distance.Text = math.floor(distance) .. "m"
        drawings.Distance.Position = Vector2.new(rootPosition.X, rootPosition.Y + height/2 + 5)
        drawings.Distance.Visible = true
    end
end

-- Interface
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "ESPMenu"
ScreenGui.Parent = game.CoreGui
ScreenGui.ResetOnSpawn = false

local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 280, 0, 680) -- Aumentado para avisos
MainFrame.Position = UDim2.new(0, 20, 0, 20)
MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
MainFrame.BorderSizePixel = 0
MainFrame.Active = true
MainFrame.Draggable = true
MainFrame.Parent = ScreenGui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 8)
UICorner.Parent = MainFrame

-- T√≠tulo
local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, 0, 0, 35)
Title.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
Title.BorderSizePixel = 0
Title.Text = "üî• AIM ASSIST ULTRA üî•"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 18
Title.Font = Enum.Font.GothamBold
Title.Parent = MainFrame

local TitleCorner = Instance.new("UICorner")
TitleCorner.CornerRadius = UDim.new(0, 8)
TitleCorner.Parent = Title

-- Fun√ß√£o bot√£o
local function CreateButton(name, posY, color, textSize)
    local Button = Instance.new("TextButton")
    Button.Size = UDim2.new(0.9, 0, 0, 28)
    Button.Position = UDim2.new(0.05, 0, 0, posY)
    Button.BackgroundColor3 = color or Color3.fromRGB(70, 70, 70)
    Button.BorderSizePixel = 0
    Button.Text = name .. ": OFF"
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.TextSize = textSize or 11
    Button.Font = Enum.Font.GothamBold
    Button.Parent = MainFrame
    
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 6)
    Corner.Parent = Button
    
    return Button
end

-- Bot√µes
local ToggleESP = CreateButton("ESP", 40, Color3.fromRGB(200, 50, 50))
local ToggleAim = CreateButton("AIM ASSIST", 72, Color3.fromRGB(200, 50, 50), 12)
local ToggleShootMode = CreateButton("ON SHOOT ONLY", 104, Color3.fromRGB(0, 100, 200))
local ToggleMagnet = CreateButton("MAGNET MODE", 136, Color3.fromRGB(150, 0, 150))
local ToggleLock = CreateButton("LOCK TARGET", 168, Color3.fromRGB(100, 100, 0))
local ToggleTeamESP = CreateButton("Team Check ESP", 200, Color3.fromRGB(70, 70, 70))
local ToggleTeamAim = CreateButton("Team Check Aim", 232, Color3.fromRGB(50, 150, 50))
local ToggleWallCheck = CreateButton("Wall Check", 264, Color3.fromRGB(70, 70, 70))
local TogglePriority = CreateButton("PRIORITY: DISTANCE", 296, Color3.fromRGB(0, 150, 255), 11)

-- üëª BOT√ÉO: Invisibilidade (CLIENT-SIDE)
local ToggleInvis = CreateButton("INVISIBILITY", 328, Color3.fromRGB(100, 0, 150), 11)

-- Bot√£o para esconder/mostrar painel
local TogglePanel = CreateButton("HIDE PANEL", 360, Color3.fromRGB(100, 100, 100))
TogglePanel.Text = "HIDE PANEL üëÅÔ∏è"

-- Container do Slider de FOV
local SliderContainer = Instance.new("Frame")
SliderContainer.Size = UDim2.new(0.9, 0, 0, 50)
SliderContainer.Position = UDim2.new(0.05, 0, 0, 392)
SliderContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
SliderContainer.BorderSizePixel = 0
SliderContainer.Parent = MainFrame

local SliderCorner = Instance.new("UICorner")
SliderCorner.CornerRadius = UDim.new(0, 6)
SliderCorner.Parent = SliderContainer

-- Label do FOV
local FOVLabel = Instance.new("TextLabel")
FOVLabel.Size = UDim2.new(1, 0, 0, 20)
FOVLabel.Position = UDim2.new(0, 0, 0, 5)
FOVLabel.BackgroundTransparency = 1
FOVLabel.Text = "FOV: 1000"
FOVLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
FOVLabel.TextSize = 12
FOVLabel.Font = Enum.Font.GothamBold
FOVLabel.Parent = SliderContainer

-- Barra de fundo do slider
local SliderBG = Instance.new("Frame")
SliderBG.Size = UDim2.new(0.9, 0, 0, 8)
SliderBG.Position = UDim2.new(0.05, 0, 0, 28)
SliderBG.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
SliderBG.BorderSizePixel = 0
SliderBG.Parent = SliderContainer

local SliderBGCorner = Instance.new("UICorner")
SliderBGCorner.CornerRadius = UDim.new(0, 4)
SliderBGCorner.Parent = SliderBG

-- Barra de preenchimento
local SliderFill = Instance.new("Frame")
SliderFill.Size = UDim2.new(0.5, 0, 1, 0)
SliderFill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
SliderFill.BorderSizePixel = 0
SliderFill.Parent = SliderBG

local SliderFillCorner = Instance.new("UICorner")
SliderFillCorner.CornerRadius = UDim.new(0, 4)
SliderFillCorner.Parent = SliderFill

-- Bot√£o arrast√°vel
local SliderKnob = Instance.new("TextButton")
SliderKnob.Size = UDim2.new(0, 16, 0, 16)
SliderKnob.Position = UDim2.new(0.5, -8, 0.5, -8)
SliderKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
SliderKnob.BorderSizePixel = 0
SliderKnob.Text = ""
SliderKnob.Parent = SliderBG

local SliderKnobCorner = Instance.new("UICorner")
SliderKnobCorner.CornerRadius = UDim.new(1, 0)
SliderKnobCorner.Parent = SliderKnob

-- Labels min/max
local MinLabel = Instance.new("TextLabel")
MinLabel.Size = UDim2.new(0, 30, 0, 15)
MinLabel.Position = UDim2.new(0.05, 0, 0, 38)
MinLabel.BackgroundTransparency = 1
MinLabel.Text = "10"
MinLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
MinLabel.TextSize = 9
MinLabel.Font = Enum.Font.Gotham
MinLabel.Parent = SliderContainer

local MaxLabel = Instance.new("TextLabel")
MaxLabel.Size = UDim2.new(0, 30, 0, 15)
MaxLabel.Position = UDim2.new(0.85, 0, 0, 38)
MaxLabel.BackgroundTransparency = 1
MaxLabel.Text = "1500"
MaxLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
MaxLabel.TextSize = 9
MaxLabel.Font = Enum.Font.Gotham
MaxLabel.Parent = SliderContainer

-- Status label
local StatusLabel = Instance.new("TextLabel")
StatusLabel.Size = UDim2.new(0.9, 0, 0, 20)
StatusLabel.Position = UDim2.new(0.05, 0, 0, 446)
StatusLabel.BackgroundTransparency = 1
StatusLabel.Text = "Status: Esperando tiro..."
StatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
StatusLabel.TextSize = 10
StatusLabel.Font = Enum.Font.GothamBold
StatusLabel.Parent = MainFrame

-- Label modo
local ModeLabel = Instance.new("TextLabel")
ModeLabel.Size = UDim2.new(0.9, 0, 0, 30)
ModeLabel.Position = UDim2.new(0.05, 0, 0, 469)
ModeLabel.BackgroundTransparency = 1
ModeLabel.Text = "MODO: Clique esquerdo para ativar aim"
ModeLabel.TextColor3 = Color3.fromRGB(0, 200, 255)
ModeLabel.TextSize = 10
ModeLabel.Font = Enum.Font.Gotham
ModeLabel.TextWrapped = true
ModeLabel.Parent = MainFrame

-- Label de prioridade
local PriorityLabel = Instance.new("TextLabel")
PriorityLabel.Size = UDim2.new(0.9, 0, 0, 20)
PriorityLabel.Position = UDim2.new(0.05, 0, 0, 499)
PriorityLabel.BackgroundTransparency = 1
PriorityLabel.Text = "üéØ Alvo: Mais pr√≥ximo (3D)"
PriorityLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
PriorityLabel.TextSize = 10
PriorityLabel.Font = Enum.Font.GothamBold
PriorityLabel.Parent = MainFrame

-- üëª LABEL: Status de invisibilidade com AVISO
local InvisLabel = Instance.new("TextLabel")
InvisLabel.Size = UDim2.new(0.9, 0, 0, 20)
InvisLabel.Position = UDim2.new(0.05, 0, 0, 519)
InvisLabel.BackgroundTransparency = 1
InvisLabel.Text = "üëª Visibilidade: Normal"
InvisLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
InvisLabel.TextSize = 10
InvisLabel.Font = Enum.Font.GothamBold
InvisLabel.Parent = MainFrame

-- üî¥ AVISO IMPORTANTE sobre invisibilidade
local WarningInvisLabel = Instance.new("TextLabel")
WarningInvisLabel.Size = UDim2.new(0.9, 0, 0, 30)
WarningInvisLabel.Position = UDim2.new(0.05, 0, 0, 539)
WarningInvisLabel.BackgroundTransparency = 1
WarningInvisLabel.Text = "‚ö†Ô∏è INVISIBILIDADE: Apenas voc√™ n√£o v√™ seu personagem! Oponentes ainda te veem normalmente."
WarningInvisLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
WarningInvisLabel.TextSize = 9
WarningInvisLabel.Font = Enum.Font.Gotham
WarningInvisLabel.TextWrapped = true
WarningInvisLabel.Parent = MainFrame

-- Aviso geral
local WarningLabel = Instance.new("TextLabel")
WarningLabel.Size = UDim2.new(0.9, 0, 0, 25)
WarningLabel.Position = UDim2.new(0.05, 0, 0, 645)
WarningLabel.BackgroundTransparency = 1
WarningLabel.Text = "‚ö†Ô∏è ULTRA FORTE | Smooth: 0.95"
WarningLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
WarningLabel.TextSize = 10
WarningLabel.Font = Enum.Font.Gotham
WarningLabel.Parent = MainFrame

-- Fun√ß√£o para atualizar o slider
local function UpdateSlider(input)
    local relativeX = math.clamp((input.Position.X - SliderBG.AbsolutePosition.X) / SliderBG.AbsoluteSize.X, 0, 1)
    local newFOV = math.floor(10 + (relativeX * 1490))
    
    if AimAssist.PriorityMode == "Distance" then
        AimAssist.MaxFOVForDistance = newFOV
        FOVLabel.Text = "Max FOV Dist: " .. newFOV .. (newFOV >= 1400 and " (MAX)" or newFOV <= 20 and " (MIN)" or "")
    else
        AimAssist.FOV = newFOV
        FOVLabel.Text = "FOV: " .. newFOV .. (newFOV >= 1400 and " (MAX)" or newFOV <= 20 and " (MIN)" or "")
    end
    
    SliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
    SliderKnob.Position = UDim2.new(relativeX, -8, 0.5, -8)
    
    if FOV_Circle then 
        if AimAssist.PriorityMode == "Distance" then
            FOV_Circle.Radius = AimAssist.MaxFOVForDistance
        else
            FOV_Circle.Radius = newFOV 
        end
    end
end

-- Eventos do slider
SliderKnob.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        IsDraggingSlider = true
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if IsDraggingSlider and input.UserInputType == Enum.UserInputType.MouseMovement then
        UpdateSlider(input)
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        IsDraggingSlider = false
    end
end)

SliderBG.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        UpdateSlider(input)
    end
end)

-- Fun√ß√µes bot√µes
ToggleESP.MouseButton1Click:Connect(function()
    ESP.Enabled = not ESP.Enabled
    ToggleESP.Text = "ESP: " .. (ESP.Enabled and "ON" or "OFF")
    ToggleESP.BackgroundColor3 = ESP.Enabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(200, 50, 50)
end)

ToggleAim.MouseButton1Click:Connect(function()
    AimAssist.Enabled = not AimAssist.Enabled
    ToggleAim.Text = "AIM ASSIST: " .. (AimAssist.Enabled and "ON üî•" or "OFF")
    ToggleAim.BackgroundColor3 = AimAssist.Enabled and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(200, 50, 50)
    if AimAssist.Enabled then
        Title.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        wait(0.2)
        Title.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
    end
end)

ToggleShootMode.MouseButton1Click:Connect(function()
    AimAssist.ShootToActivate = not AimAssist.ShootToActivate
    if AimAssist.ShootToActivate then
        ToggleShootMode.Text = "ON SHOOT ONLY: ON üéØ"
        ToggleShootMode.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
        ModeLabel.Text = "MODO: Clique esquerdo para ativar aim"
        ModeLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
    else
        ToggleShootMode.Text = "ALWAYS ON: ON ‚ö°"
        ToggleShootMode.BackgroundColor3 = Color3.fromRGB(255, 100, 0)
        ModeLabel.Text = "MODO: Sempre ativo quando ligado"
        ModeLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
    end
end)

ToggleMagnet.MouseButton1Click:Connect(function()
    AimAssist.MagnetMode = not AimAssist.MagnetMode
    ToggleMagnet.Text = "MAGNET: " .. (AimAssist.MagnetMode and "ON üß≤" or "OFF")
    ToggleMagnet.BackgroundColor3 = AimAssist.MagnetMode and Color3.fromRGB(255, 0, 255) or Color3.fromRGB(150, 0, 150)
end)

ToggleLock.MouseButton1Click:Connect(function()
    AimAssist.LockTarget = not AimAssist.LockTarget
    ToggleLock.Text = "LOCK: " .. (AimAssist.LockTarget and "ON üîí" or "OFF")
    ToggleLock.BackgroundColor3 = AimAssist.LockTarget and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(100, 100, 0)
end)

ToggleTeamESP.MouseButton1Click:Connect(function()
    ESP.TeamCheck = not ESP.TeamCheck
    ToggleTeamESP.Text = "Team ESP: " .. (ESP.TeamCheck and "ON" or "OFF")
    ToggleTeamESP.BackgroundColor3 = ESP.TeamCheck and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(70, 70, 70)
end)

ToggleTeamAim.MouseButton1Click:Connect(function()
    AimAssist.TeamCheck = not AimAssist.TeamCheck
    ToggleTeamAim.Text = "Team Aim: " .. (AimAssist.TeamCheck and "ON" or "OFF")
    ToggleTeamAim.BackgroundColor3 = AimAssist.TeamCheck and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(50, 150, 50)
end)

ToggleWallCheck.MouseButton1Click:Connect(function()
    AimAssist.WallCheck = not AimAssist.WallCheck
    ToggleWallCheck.Text = "Wall Check: " .. (AimAssist.WallCheck and "ON" or "OFF")
    ToggleWallCheck.BackgroundColor3 = AimAssist.WallCheck and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(70, 70, 70)
end)

TogglePriority.MouseButton1Click:Connect(function()
    if AimAssist.PriorityMode == "Distance" then
        AimAssist.PriorityMode = "FOV"
        TogglePriority.Text = "PRIORITY: FOV (CENTER)"
        TogglePriority.BackgroundColor3 = Color3.fromRGB(255, 100, 0)
        PriorityLabel.Text = "üéØ Alvo: Mais central (tela)"
        PriorityLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
        local relativeX = math.clamp((AimAssist.FOV - 10) / 1490, 0, 1)
        SliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
        SliderKnob.Position = UDim2.new(relativeX, -8, 0.5, -8)
        FOVLabel.Text = "FOV: " .. AimAssist.FOV
    else
        AimAssist.PriorityMode = "Distance"
        TogglePriority.Text = "PRIORITY: DISTANCE"
        TogglePriority.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
        PriorityLabel.Text = "üéØ Alvo: Mais pr√≥ximo (3D)"
        PriorityLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
        local relativeX = math.clamp((AimAssist.MaxFOVForDistance - 10) / 1490, 0, 1)
        SliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
        SliderKnob.Position = UDim2.new(relativeX, -8, 0.5, -8)
        FOVLabel.Text = "Max FOV Dist: " .. AimAssist.MaxFOVForDistance
    end
end)

-- üëª Fun√ß√£o do bot√£o de invisibilidade (CLIENT-SIDE)
ToggleInvis.MouseButton1Click:Connect(function()
    local isInvisible = ToggleInvisibility()
    if isInvisible then
        ToggleInvis.Text = "INVISIBILITY: ON üëª"
        ToggleInvis.BackgroundColor3 = Color3.fromRGB(200, 0, 255)
        InvisLabel.Text = "üëª Visibilidade: Invis√≠vel (s√≥ para voc√™)"
        InvisLabel.TextColor3 = Color3.fromRGB(255, 100, 255)
    else
        ToggleInvis.Text = "INVISIBILITY: OFF"
        ToggleInvis.BackgroundColor3 = Color3.fromRGB(100, 0, 150)
        InvisLabel.Text = "üëª Visibilidade: Normal"
        InvisLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    end
end)

-- Fun√ß√£o do bot√£o esconder/mostrar painel
Toggle
